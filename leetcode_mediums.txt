// Leetcode 901 - Online Stock Span

class StockSpanner {
    int smaller = 0;
    int index = 0;
    ArrayList<Integer> a = new ArrayList<Integer>();
    public StockSpanner() {
        
    }
    
    public int next(int price) {
        smaller = 0;
        a.add(price);
        index = a.size()-1;
        while( index > -1 && a.get(index) <= price ){
            smaller++;
            index--;
        }
        return smaller;
    }
}

// Leetcode 739 - Daily Temperatures

class Solution739(object):
    def dailyTemperatures(self, temperatures):
        """
        :type temperatures: List[int]
        :rtype: List[int]
        """
        if len(temperatures) <= 1:
            return [0]
        stack = [len(temperatures)-1]
        ans = [0]
        for pos in range(len(temperatures)-2, -1, -1):
            while len(stack) > 0 and temperatures[stack[-1]] <= temperatures[pos]:
                stack.pop()
            if len(stack) == 0:
                ans.append(0)
            else:
                ans.append(stack[-1]-pos)
            stack.append(pos)
        ans.reverse()
        return ans

// Leetcode 152 - Maximum Product Subarray

class Solution {
    public int maxProduct(int[] nums) {
        if( nums.length == 1 ) return nums[0];
        int positive = 1;
        int negative = 1;
        int max = 0;
        for(int i=0; i < nums.length; i++){
            if( nums[i] < 0 ){
                negative *= nums[i]; 
                max = Math.max(negative, max);
                positive = 1;
            }
            else if( nums[i] == 0 ){ positive = 1; negative = 1; }
            else{
                positive *= nums[i];
                negative *= nums[i];
                max = Math.max(positive, max);
                if( negative > 0 ) max = Math.max(max, negative);
            }
        }
        positive = 1;
        negative = 1;
        for(int i=nums.length-1; i > -1; i--){
            if( nums[i] < 0 ){
                negative *= nums[i]; 
                max = Math.max(negative, max);
                positive = 1;
            }
            else if( nums[i] == 0 ){ positive = 1; negative = 1; }
            else{
                positive *= nums[i];
                negative *= nums[i];
                max = Math.max(positive, max);
                if( negative > 0 ) max = Math.max(max, negative);
            }
        }
        return max;
    }
}

// Leetcode 2491 - Divide Players Into Teams of Equal Skill

class Solution2491 {
    public long dividePlayers(int[] skill) {
        long product = 0;
        int sum = 0;
        int n = 0;
        HashMap<Integer, Integer> freq = new HashMap<Integer, Integer>();
        for(int i=0; i < skill.length; i++){
            sum += skill[i];
            if( !freq.containsKey(skill[i]) ) freq.put(skill[i], 1);
            else freq.put(skill[i], freq.get(skill[i])+1);
        }
        if( 2*sum%skill.length != 0 ) return -1;
        sum = 2*sum/skill.length;
        for(int i=0; i < skill.length; i++){
            if( freq.containsKey(sum-skill[i]) && freq.get(sum-skill[i]) > 0 && freq.get(skill[i]) > 0 ){
                product += skill[i]*(sum-skill[i]);
                freq.put(sum-skill[i], freq.get(sum-skill[i])-1);
                freq.put(skill[i], freq.get(skill[i])-1);
                n++;
            }
        }
        return (n==skill.length/2)?product:-1;
    }
}

// Leetcode 2497 - Maximum Star Sum of a Graph

class Solution2497(object):
    def maxStarSum(self, vals, edges, k):
        graph = {}
        maximum = 0
        temp = 0
        curr = []
        iterate = 0
        for i in edges:
            if i[0] in graph:
                graph[i[0]].append(vals[i[1]])
            else:
                graph[i[0]] = [vals[i[1]]]
            if i[1] in graph:
                graph[i[1]].append(vals[i[0]])
            else:
                graph[i[1]] = [vals[i[0]]]
                    
         
        for i in graph:
            graph[i].sort()
            for j in range(len(graph[i])-1, -1, -1):
                if iterate == k or graph[i][j] <= 0:
                    break
                temp += graph[i][j]
                iterate += 1
            maximum = max(maximum, temp+vals[i])
            temp = 0
            iterate = 0
                
        if maximum == 0:
            return max(vals)
        else:
            return maximum

// Leetcode 11 - Container With Most Water

class Solution11 {
    public int maxArea(int[] height) {
        int a = 0;
        int b = height.length-1;
        int maxArea = 0;
        while( a < b && b < height.length ){
            maxArea = Math.max(maxArea, Math.min(height[a], height[b])*(b-a));
            if( height[a] < height[b] ) a++;
            else b--;
        }
        return maxArea;
    }
}

// Leetcode 2425 - Bitwise XOR of All Pairings

class Solution {
    public int xorAllNums(int[] nums1, int[] nums2) {
        int xor = 0;
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        for(int i=0; i < nums1.length; i++){
            if( !map.containsKey(nums1[i]) ) map.put(nums1[i], nums2.length);
            else map.put(nums1[i], map.get(nums1[i])+nums2.length);
        }
        for(int i=0; i < nums2.length; i++){
            if( !map.containsKey(nums2[i]) ) map.put(nums2[i], nums1.length);
            else map.put(nums2[i], map.get(nums2[i])+nums1.length);
        }
        for(int key : map.keySet()){
            if( map.get(key)%2 != 0 ) xor ^= key;
        }
        return xor;
    }
}

// Leetcode 1877 - Minimise Maximum Pair Sum in Array

class Solution1877 {
    public int minPairSum(int[] nums) {
        Arrays.sort(nums);
        int max = 0;
        for(int i=0; i < nums.length/2; i++){
            max = Math.max(max, nums[i]+nums[nums.length-1-i]);
        }
        return max;
    }
}

// Leetcode 2279 - Maximum Bags With Full Capacity of Rocks

class Solution2279 {
    public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {
        int bags = 0;
        for(int i=0; i < capacity.length; i++){
            capacity[i] -= rocks[i];
        }
        Arrays.sort(capacity);
        for(int i=0; i < capacity.length; i++){
            if( additionalRocks == 0 ) break;
            else if( capacity[i] > additionalRocks ) break;
            else{
                bags++;
                additionalRocks -= capacity[i];
            }
        }
        return bags;
    }
}

// Leetcode 2512 - Reward Top K Students

class Solution2512:
    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:
        
        p = set(positive_feedback)
        s = set(negative_feedback)
        
        students_left = k
        current_scores = []
        top_k_students = []
        student_ranks = [0]*len(report)
        words = []
        id_map = {}
        for i in range(len(report)):
            words = report[i].split()
            for j in words:
                if j in p:
                    student_ranks[i] += 3
                elif j in s:
                    student_ranks[i] -= 1
                    
        for i in range(len(student_ranks)):
            id_map[student_id[i]] = student_ranks[i]
        
        student_ranks = list(dict.fromkeys(student_ranks))
        student_ranks.sort()

        # UP TO HERE CODE IS CLEAN
        for i in range(len(student_ranks)-1, len(student_ranks)-k-1, -1):
            current_scores = []
            for j in id_map:
                if id_map[j] == student_ranks[i]:
                    current_scores.append(j)
            
            current_scores.sort()
            if len(current_scores) >= students_left:
                for i in range(students_left):
                    top_k_students.append(current_scores[i])
                return top_k_students
            else:
                for i in current_scores:
                    top_k_students.append(i)
            students_left -= len(current_scores)
                
        return top_k_students

// Leetcode 692 - Top K Frequent Words

class Solution692:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        top_k_words = []
        frequency = {}
        sorted_list = []
        same_frequency = {}
        for i in words:
            if i in frequency:
                frequency[i] += 1
            else:
                frequency[i] = 1
        sorted_map = dict(sorted(frequency.items(), key=lambda item: item[1], reverse=True))
        words_left = k
        for i in sorted_map:
            if sorted_map[i] in same_frequency:
                same_frequency[sorted_map[i]].append(i)
            else:
                same_frequency[sorted_map[i]] = [i]
        
        for i in same_frequency:
            same_frequency[i] = sorted(same_frequency[i])
            if len(same_frequency[i]) >= words_left:
                for j in range(words_left):
                    top_k_words.append(same_frequency[i][j])
                return top_k_words
            else:
                for j in same_frequency[i]:
                    top_k_words.append(j)
            words_left -= len(same_frequency[i])
        return top_k_words

// Leetcode 7 - Reverse Integer

class Solution7 {
    public int reverse(int x) {
        long multiply = 1;
        int sign = (x<0)?-1:1;
        long reverse = 0;
        x = Math.abs(x);
        int copy = x;
        while( copy > 0 ){
            copy /= 10;
            multiply *= 10;
        }
        multiply /= 10;
        while( x > 0 ){
            reverse += multiply * (x % 10);
            multiply /= 10;
            x /= 10;
        }
        if( reverse > Integer.MAX_VALUE ) reverse = 0;
        return sign*((int)reverse);
    }
}

// Leetcode 1814 - Count Nice Pairs in an Array

class Solution1814 {
    public int rev(int x){
        long multiply = 1;
        long reverse = 0;
        int copy = x;
        while( copy > 0 ){
            copy /= 10;
            multiply *= 10;
        }
        multiply /= 10;
        while( x > 0 ){
            reverse += multiply * (x % 10);
            multiply /= 10;
            x /= 10;
        }
        if( reverse > Integer.MAX_VALUE ) reverse = 0;
        return (int)reverse;
    }
    public int countNicePairs(int[] nums) {
        int reverse = 0;
        long pairs = 0;
        HashMap<Integer, Integer> frequency = new HashMap<Integer, Integer>();
        for(int i=0; i < nums.length; i++){
            reverse = rev(nums[i]);
            if( !frequency.containsKey(nums[i]-reverse) ) frequency.put(nums[i]-reverse, 1);
            else frequency.put(nums[i]-reverse, frequency.get(nums[i]-reverse)+1);
        }
        for(int i : frequency.keySet()){
            if( frequency.get(i) != 1 ) pairs += ((long)frequency.get(i))*((long)(frequency.get(i)-1))/2;
        }
        // nums[i] - rev(nums[i]) = nums[j] - rev(nums[j])
        // Keep frequency 
        // Sum frequency if greater than 1            
        return (int)(pairs%(1000000007));
    }
}

// Leetcode 904 - Fruit Baskets

class Solution904 {
    public int totalFruit(int[] fruits) {
        if( fruits.length == 1 ) return 1;
        int[] trees = new int[]{fruits[0], fruits[1]};
        int nums1 = 0;
        int nums2 = 0;
        int streak1 = 0;
        int streak2 = 0;
        int maximumFruit = 0;
        for(int i=0; i < fruits.length; i++){
            if( fruits[i] != trees[0] && fruits[i] != trees[1] ){
                maximumFruit = Math.max(maximumFruit, nums1+nums2);
                if( streak1 == 0 ){
                    trees[0] = trees[1];
                    trees[1] = fruits[i];
                    nums1 = streak2;
                }
                else{
                    trees[1] = fruits[i];
                    nums1 = streak1;
                }
                nums2 = 1;
                streak2 = 1;
                streak1 = 0;
            }
            else if( fruits[i] == trees[0] ){ nums1++; streak1++; streak2 = 0; }
            else{ nums2++; streak2++; streak1 = 0; }
        }
        maximumFruit = Math.max(maximumFruit, nums1+nums2);
        return maximumFruit;
    }
}

// Leetcode 452 - Minimum Number of Arrows to Brust Balloons

class Solution452 {
    public int findMinArrowShots(int[][] points) {
        if( points.length == 1 ) return 1;
        Arrays.sort(points, (int[] o1, int[] o2) -> o2[0] - o1[0]);
        if( points.length == 2 ){ 
            if( points[1][1] >= points[0][0] && points[1][0] <= points[0][1] ) return 1;
            else return 2;
        }
        int arrows = 0;
        int start = 0;
        for(int i=0; i < points.length; i++){
            while( i < points.length && points[i][1] >= points[start][0] && points[i][0] <= points[i][1] ){
                i++;
            }
            if( i < points.length ){
                if( points[i][1] < points[start][0] || points[i][0] > points[i][1] ){
                    start = i;
                    arrows++;
                }
            }
        }
        return arrows+1;
    }
}

// Leetcode 2526 - Find Consecutive Integers from a Data Stream

class DataStream(object):

    def __init__(self, value, k):
        self.value = value
        self.k = k
        self.start = 0
        self.numbers = []
        self.consecutive = False
        self.equal = 0
        

    def consec(self, num):
        self.consecutive = False
        self.numbers.append(num)
        if num == self.value:
            self.equal += 1
        if len(self.numbers) < self.k:
            return False
        elif len(self.numbers) >= self.k:
            if self.equal == self.k:
                self.consecutive = True
            if self.numbers[self.start] == self.value:
                self.equal -= 1
            self.start += 1
             
        return self.consecutive

// Leetcode 2527 - Find Xor-Beauty of Array

class Solution2527 {
    public int xorBeauty(int[] nums) {
        int beauty = nums[0];
        for(int i=1; i < nums.length; i++){
            beauty ^= nums[i];
        }
        return beauty;
    }
}

// Leetcode 2501 - Longest Square Streak in an Array

class Solution2501:
    def verifySquare(self, n):
        if( n == int(n) ):
            return True
        return False
    
    def longestSquareStreak(self, nums: List[int]) -> int:
        val = 1
        result = -1
        values = set()
        current = 0
        for i in nums:
            values.add(i)
        for i in values:
            current = i
            if( self.verifySquare(math.sqrt(current)) and i*i not in values ):
                while self.verifySquare(math.sqrt(current)) and int(current) in values:
                    current = math.sqrt(current)
                    if current in values:
                        val += 1
                if val > 1:
                    result = max(val, result)
                val = 1
        return result

// Leetcode 2541 - Minimum Operations to Make Array Equal II

class Solution:
    def minOperations(self, nums1: List[int], nums2: List[int], k: int) -> int:
        if k == 0:
            if nums1 == nums2:
                return 0
            else:
                return -1
        ops_map = {}
        min_operations = 0
        sum_ops_map = 0
        calc = 0
        for i in range(len(nums1)):
            calc = (nums2[i] - nums1[i]) / k
            if int(calc) != calc:
                return -1
            calc = int(calc)
            if calc in ops_map:
                ops_map[calc] += 1
            else:
                ops_map[calc] = 1
        calc = 0
        for i in ops_map:
            if i > 0:
                min_operations += i*ops_map[i]
            sum_ops_map += i * ops_map[i]
        if sum_ops_map != 0:
            return -1
        return min_operations

// Leetcode 57 - Insert Interval

class Solution57 {
    public int[][] merge(int[][] intervals) {
        if( intervals.length <= 1 ) return intervals;
        Arrays.sort(intervals, (int[] o1, int[] o2) -> o1[0] - o2[0]);
        ArrayList<int[]> distinct = new ArrayList<int[]>();
        int i=0;
        int j=1;
        int num = 0;
        int currentEnd = intervals[0][1];
        int currentStart = 0;
        while( j < intervals.length && num < 1 ){
            currentStart = intervals[i][0];
            while( intervals[j][0] <= currentEnd ){
                currentEnd = Math.max(intervals[j][1], currentEnd);
                if( j >= intervals.length-1 ){
                    num++;
                    break;
                }
                else{
                    j++;
                    i++;
                }
            }
            distinct.add(new int[]{currentStart, currentEnd});
            i++;
            j++;
            currentEnd = intervals[i][1];
        }
        if( distinct.get(distinct.size()-1)[1] != intervals[intervals.length-1][1] && intervals[intervals.length-1][1] > distinct.get(distinct.size()-1)[1]){
            distinct.add(new int[]{intervals[intervals.length-1][0], intervals[intervals.length-1][1]});
        }
        int[][] values = new int[distinct.size()][2];
        for(int a=0; a < distinct.size(); a++){
            values[a] = distinct.get(a);
        }
        return values;
    }
    public int[][] insert(int[][] intervals, int[] newInterval) {
        int[][] secondaryIntervals = new int[intervals.length+1][2];
        for(int i=0; i < intervals.length; i++){
            secondaryIntervals[i] = intervals[i];
        }
        secondaryIntervals[intervals.length] = newInterval;
        return merge(secondaryIntervals);
    }
}

// Leetcode 1701 - Average Waiting Time

class Solution {
    public double averageWaitingTime(int[][] customers) {
        double time = 0;
        int prev = 0;
        int finishTime = 0;
        for(int i=0; i < customers.length; i++){
            if( finishTime > customers[i][0] ){
                time += finishTime-customers[i][0];
            }
            else finishTime = customers[i][0];
            finishTime += customers[i][1];
            time += customers[i][1];
        }
        return time / customers.length;
    }
}

// Leetcode 2414 - Length of the Longest Alphabetical Continuous Substring

class Solution2414 {
    public int longestContinuousSubstring(String s) {
        int longest = 1;
        int length = 0;
        int prev = 0;
        for(int i=0; i < s.length(); i++){
            prev = s.charAt(i)-1;
            while( i < s.length() && s.charAt(i)-1 == prev ){
                prev = s.charAt(i);
                length++;
                i++;
            }
            i--;
            longest = Math.max(longest, length);
            length = 0;
        }
        return longest;
    }
}

// Leetcode 2482 - Difference Between Ones and Zeros in Row and Column

class Solution2482 {
    public int[][] onesMinusZeros(int[][] grid) {
        int[][] diff = new int[grid.length][grid[0].length];
        int[] onesRow = new int[grid.length];
        int[] onesColumn = new int[grid[0].length];
        for(int i=0; i < grid.length; i++){
            for(int j=0; j < grid[0].length; j++){
                if( grid[i][j] == 1 ){
                    onesRow[i]++;
                    onesColumn[j]++;
                }
            }
        }
        for(int i=0; i < grid.length; i++){
            for(int j=0; j < grid[0].length; j++){
                diff[i][j] = 2*(onesRow[i] + onesColumn[j]) - (grid.length + grid[0].length);
            }
        }
        return diff;
    }
}


// Leetcode 2545 - Sort the Students by Their Kth Score

class Solution:
    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:
        student_map = {}
        sorted_students = []
        for i in range(len(score)):
            student_map[i] = score[i][k]
        sorted_map = dict(sorted(student_map.items(), key=lambda item: item[1], reverse=True))
        for i in sorted_map:
            sorted_students.append(score[i])
        return sorted_students

// Leetcode 954 - Array of Doubled Pairs

class Solution {
    public boolean canReorderDoubled(int[] arr) {
        int min = 0;
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        for(int i=0; i < arr.length; i++){
            if( !map.containsKey(arr[i]) ) map.put(arr[i], 1);
            else map.put(arr[i], map.get(arr[i])+1);
        }
        for(int i : map.keySet()){
            if( map.get(i) != 0 ){
                if( i % 2 == 0 ){
                    if( map.containsKey(2*i) && map.get(2*i) > 0 ){
                        min = Math.min(map.get(i), map.get(2*i));
                        map.put(i, map.get(i) - min);
                        map.put(2*i, map.get(2*i) - min);
                    }
                    else if( map.containsKey(i/2) && map.get(i/2) > 0){
                        min = Math.min(map.get(i), map.get(i/2));
                        map.put(i, map.get(i) - min);
                        map.put(i/2, map.get(i/2) - min);
                    }
                    else return false;
                }
                else if( map.containsKey(2*i) ){
                    if( map.get(2*i) == 0 ) return false;
                    min = Math.min(map.get(i), map.get(2*i));
                    map.put(i, map.get(i) - min);
                    map.put(2*i, map.get(2*i) - min);
                }   
                else return false;
            }
        }
        for(int i : map.keySet()){
            if( map.get(i) > 0 ) return false;
        }
        return true;
        /*
        frequency(i) == frequency(2*i)
        */
    }
}

// Leetcode 1038 - Binary Search Tree to Greater Sum Tree

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.nodes = []
        self.greater_map = {}
        
    def dfs(self, root):
        if root != None:
            self.nodes.append(root.val)
            if root.left != None:
                self.dfs(root.left)
            if root.right != None:
                self.dfs(root.right)
    
    def add(self, root):
        if root != None:
            root.val += self.greater_map[root.val]
            if root.left != None:
                self.add(root.left)
            if root.right != None:
                self.add(root.right)
                
    def bstToGst(self, root: TreeNode) -> TreeNode:
        self.dfs(root)
        self.nodes.sort()
        greater_sum = 0
        for i in range(len(self.nodes)-1, -1, -1):
            self.greater_map[self.nodes[i]] = greater_sum
            greater_sum += self.nodes[i]
        self.add(root)
        return root

// Leetcode 973 - K Closest Points to Origin

class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        frequency_map = {}
        distance_map = {}
        k_closest = []
        for i in points:
            distance_map[(i[0], i[1])] = sqrt(i[0]**2 + i[1]**2)
            if (i[0], i[1]) not in frequency_map:
                frequency_map[(i[0], i[1])] = 1
            else:
                frequency_map[(i[0], i[1])]+= 1
        sorted_map = dict(sorted(distance_map.items(), key=lambda item: item[1], reverse=False))
        for i in sorted_map:
            if frequency_map[i] >= k:
                for j in range(k):
                    k_closest.append([i[0], i[1]])
                return k_closest
            else:
                for j in range(frequency_map[i]):
                    k_closest.append([i[0], i[1]])
                k -= frequency_map[i]
        return k_closest

// Leetcode 2196 - Create Binary Tree From Descriptions

class Solution {
    public TreeNode createBinaryTree(int[][] descriptions) {
        HashMap<Integer, TreeNode> map = new HashMap<Integer, TreeNode>();
        HashSet<Integer> children = new HashSet<Integer>();
        HashSet<Integer> parents = new HashSet<Integer>();
        for(int i=0; i < descriptions.length; i++){
            children.add(descriptions[i][1]);
            parents.add(descriptions[i][0]);
            if( !map.containsKey(descriptions[i][0]) ){
                map.put(descriptions[i][0], new TreeNode(descriptions[i][0]));
            }
            if( !map.containsKey(descriptions[i][1]) ){
                map.put(descriptions[i][1], new TreeNode(descriptions[i][1]));
            }
            if( descriptions[i][2] == 1 ) map.get(descriptions[i][0]).left = map.get(descriptions[i][1]);
            else map.get(descriptions[i][0]).right = map.get(descriptions[i][1]);
        }
        for(int i : parents){
            if( !children.contains(i) ) return map.get(i);
        }
        return new TreeNode(0);
    }
}

// Leetcode 1023 - Camelcase Matching

class Solution:
    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:
        temp = 0
        matched = []
        for i in queries:
            for j in i:
                if ord(j) > 64 and ord(j) < 91:
                    if temp >= len(pattern) or j != pattern[temp]:
                        temp = -1
                        break
                if temp < len(pattern) and j == pattern[temp]:
                    temp += 1
            if temp == len(pattern):
                matched.append(True)
            else:
                matched.append(False)
            temp = 0
        return matched

// Leetcode 1282 - Group the People Given the Group Size They Belong To

class Solution1282:
    def divide_chunks(self, l, n):
        for i in range(0, len(l), n):
            yield l[i:i + n]
        
    def groupThePeople(self, groupSizes: List[int]) -> List[List[int]]:
        group_map = {}
        groups = []
        temp = []
        for i in range(len(groupSizes)):
            if groupSizes[i] in group_map:
                group_map[groupSizes[i]].append(i)
            else:
                group_map[groupSizes[i]] = [i]
        for i in group_map:
            temp = list(self.divide_chunks(group_map[i], i))
            for i in temp:
                groups.append(i)
        return groups

// Leetcode 677 - Map Sum Pairs

class MapSum677:

    def __init__(self):
        self.map = {}
        self.val_map = {}
        self.string = ""

    def insert(self, key: str, val: int) -> None:
        initial = 0
        if key in self.val_map:
            initial = self.val_map[key]
        self.val_map[key] = val
        for i in key:
            self.string += i
            if self.string not in self.map:
                self.map[self.string] = self.val_map[key]
            else:
                self.map[self.string] += self.val_map[key] - initial
        self.string = ""

    def sum(self, prefix: str) -> int:
        if prefix in self.map:
            return self.map[prefix]
        return 0

// Leetcode 567 - Permutation in String

class Solution567:
    def __init__(self):
        self.map = {}
        self.freq =  {}
        
    def checkInclusion(self, s1: str, s2: str) -> bool:
        fullfill = True
        windowStart =  0
        for i in s1:
            if i not in self.map:
                self.map[i] = 1
            else:
                self.map[i] += 1
        
        for i in range(len(s2)):
            if s2[i] not in self.freq:
                self.freq[s2[i]] = 1
            else:
                self.freq[s2[i]] += 1
                
            if i - windowStart + 1 == len(s1):
                for i in self.freq:
                    if i not in self.map:
                        if self.freq[i] > 0:
                            fullfill = False
                            break
                    elif self.map[i] != self.freq[i]:
                        fullfill = False
                        break
                if fullfill:
                    return True
                fullfill = True
                self.freq[s2[windowStart]] -= 1
                windowStart += 1
        
        return False

// Leetcode 2554 - Maximum Number of Integers to Choose From a Range I

class Solution2554:
    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:
        banned_set = set()
        temp_sum = 0
        numbers = 0
        
        for i in banned:
            banned_set.add(i)
        
        for i in range(1, n+1):
            if i not in banned_set:
                temp_sum += i
                numbers += 1
            if temp_sum == maxSum:
                return numbers
            elif temp_sum > maxSum:
                return numbers-1
        
        return numbers

// Leetcode 438 - Find All Anagrams in a String

class Solution438:
    def __init__(self):
        self.map = {}
        self.freq = {}
    
    def findAnagrams(self, s: str, p: str) -> List[int]:
        windowStart = 0 
        fullfill = True
        anagrams = []
        for i in p:
            if i not in self.map:
                self.map[i] = 1
            else:
                self.map[i] += 1
        
        for i in range(len(s)):
            if s[i] not in self.freq:
                self.freq[s[i]] = 1
            else:
                self.freq[s[i]] += 1
            if i - windowStart + 1 == len(p):
                for i in self.freq:
                    if i not in self.map:
                        if self.freq[i] > 0:
                            fullfill = False
                            break
                    elif self.map[i] != self.freq[i]:
                        fullfill = False
                        break
                if fullfill:
                    anagrams.append(windowStart)
                fullfill = True
                self.freq[s[windowStart]] -= 1
                windowStart += 1
        
        return anagrams

// Leetcode 6 - Zigzag Conversion

class Solution6:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1:
            return s
        rows = {}
        tempRow = 0
        index = 0
        ans = ""
        
        while index < len(s):
            if tempRow < numRows:
                if tempRow not in rows:
                    rows[tempRow] = [s[index]]
                else:
                    rows[tempRow].append(s[index])
                tempRow += 1
                index += 1
            elif tempRow == numRows:
                tempRow -= 2
                while index < len(s) and tempRow != 0:
                    if tempRow not in rows:
                        rows[tempRow] = [s[index]]
                    else:
                        rows[tempRow].append(s[index])
                    tempRow -= 1
                    index += 1
                    
        rows =  collections.OrderedDict(sorted(rows.items()))
        
        for i in rows:
            for j in rows[i]:
                ans += j
        
        return ans

// Leetcode 1261 - Find Elements in a Contaminated Binary Tree

class FindElements {
    HashSet<Integer> elements = new HashSet<Integer>();
    ArrayList<TreeNode> current = new ArrayList<TreeNode>();
    ArrayList<TreeNode> current_two = new ArrayList<TreeNode>();
    public FindElements(TreeNode root) {
        current.add(root);
        root.val = 0;
        while( current.size() != 0 ){
            while( current.size() != 0 ){
                elements.add(current.get(0).val);
                if( current.get(0).left != null ){
                    current.get(0).left.val = 2*current.get(0).val + 1;
                    current_two.add(current.get(0).left);
                }
                if( current.get(0).right != null ){
                    current.get(0).right.val = 2*current.get(0).val + 2;
                    current_two.add(current.get(0).right);
                }
                current.remove(current.get(0));
            }
            
            while( current_two.size() != 0 ){
                current.add(current_two.get(0));
                current_two.remove(current_two.get(0));
            }
        }
    }
    
    public boolean find(int target) {
        if( elements.contains(target) ) return true;
        return false;
    }
}

// Leetcode 129 - Sum Root to Leaf Numbers

class Solution129:
    
    def __init__(self):
        self.sum = 0
    
    def dfs(self, root, path):
        if root.left == None and root.right == None:
            self.sum += int(path + str(root.val))
        if root.left != None:
            self.dfs(root.left, path+str(root.val))
        if root.right != None:
            self.dfs(root.right, path+str(root.val))
            
    def sumNumbers(self, root: Optional[TreeNode]) -> int:
        self.dfs(root, "")
        return self.sum

// Leetcode 513 - Find Bottom Left Tree Value

class Solution513 {
    public int findBottomLeftValue(TreeNode root) {
        int last = 0;
        ArrayList<TreeNode> current = new ArrayList<TreeNode>();
        ArrayList<TreeNode> current_two = new ArrayList<TreeNode>();
        current.add(root);
        while( current.size() != 0 ){
            last = current.get(0).val;
            while( current.size() != 0 ){
                if( current.get(0).left != null ) current_two.add(current.get(0).left);
                if( current.get(0).right != null ) current_two.add(current.get(0).right);
                current.remove(current.get(0));
            }
            if( current_two.size() == 0 ) return last;
            while( current_two.size() != 0 ){
                current.add(current_two.get(0));
                current_two.remove(current_two.get(0));
            }
        }
        return 0;
    }
}

// Leetcode 1302 - Deepest Leaves Sum

class Solution1302 {
    public int deepestLeavesSum(TreeNode root) {
        int sum = 0;
        ArrayList<TreeNode> a = new ArrayList<TreeNode>();
        ArrayList<TreeNode> b = new ArrayList<TreeNode>();
        a.add(root);
        while( a.size() != 0 ){
            while( a.size() != 0 ){
                sum += a.get(0).val;
                if( a.get(0).left != null ) b.add(a.get(0).left);
                if( a.get(0).right != null ) b.add(a.get(0).right);
                a.remove(a.get(0));
            }
            if( b.size() == 0 ) return sum;
            sum = 0;
            while( b.size() != 0 ){
                a.add(b.get(0));
                b.remove(b.get(0));
            }
        }
        return 0;
    }
}

// Leetcode 1315 - Sum of Nodes with Even-Valued Grandparents

class Solution1315 {
    int sum = 0;
    public void dfs(TreeNode root){
        if( root.val % 2 == 0 ){
            if( root.left != null ){
                if( root.left.left != null ) sum += root.left.left.val;
                if( root.left.right != null ) sum += root.left.right.val;
            }
            if( root.right != null ){
                if( root.right.left != null ) sum += root.right.left.val;
                if( root.right.right != null ) sum += root.right.right.val;
            }
        }
        if( root.left != null ) dfs(root.left);
        if( root.right != null ) dfs(root.right);
    }
    public int sumEvenGrandparent(TreeNode root) {
        dfs(root);
        return sum;
    }
}

// Leetcode 2415 - Reverse Odd Levels of Binary Tree

class Solution2415 {
    public TreeNode reverseOddLevels(TreeNode root) {
        int rows = 0;
        int temp = 0;
        ArrayList<TreeNode> a = new ArrayList<TreeNode>();
        ArrayList<TreeNode> b = new ArrayList<TreeNode>();
        a.add(root);
        while( a.size() != 0 ){
            while( a.size() != 0 ){
                if( a.get(0).left != null ) b.add(a.get(0).left);
                if( a.get(0).right != null ) b.add(a.get(0).right);
                a.remove(a.get(0));
            }
            if( rows % 2 == 0 ){
                for(int i=0; i < b.size()/2; i++){
                    temp = b.get(i).val;
                    b.get(i).val = b.get(b.size()-1-i).val;
                    b.get(b.size()-1-i).val = temp;
                }
            }
            rows++;
            while( b.size() != 0 ){
                a.add(b.get(0));
                b.remove(b.get(0));
            }
        }
        return root;
    }
}

// Leetcode 2249 - Count Lattice Points Inside a Circle

class Solution2249:
    def countLatticePoints(self, circles: List[List[int]]) -> int:
        lattice = 0
        points = set()
        for i in circles:
            for x in range(i[0]-i[2], i[0]+i[2]+1):
                for y in range(i[1]-i[2], i[1]+i[2]+1):
                    if (x - i[0])**2 + (y - i[1])**2 <= i[2]**2:
                        points.add((x,y))
        return len(points)

// Leetcode 676 - Implement Magic Dictionary

class MagicDictionary:

    def __init__(self):
        self.dictionary = []

    def buildDict(self, dictionary: List[str]) -> None:
        self.dictionary = dictionary

    def search(self, searchWord: str) -> bool:
        diff = 0
        for i in self.dictionary:
            if len(i) == len(searchWord):
                for j in range(len(i)):
                    if i[j] != searchWord[j]:
                        diff += 1
                if diff == 1:
                    return True
            diff = 0
        return False

// Leetcode 2456 - Most Popular Video Creator

class Solution2456:
    def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:
        total_views = {}
        id_map = {}
        maximum = 0
        ans = []
        
        for i in range(len(creators)):
            if creators[i] not in total_views:
                total_views[creators[i]] = views[i]
            else:
                total_views[creators[i]] += views[i]
            
            if creators[i] not in id_map:
                id_map[creators[i]] = i
            else:
                if views[id_map[creators[i]]] < views[i]:
                    id_map[creators[i]] = i
                elif views[id_map[creators[i]]] == views[i] and ids[id_map[creators[i]]] > ids[i]:
                    id_map[creators[i]] = i
            
            maximum = max(maximum, total_views[creators[i]])

        sorted_map = dict(sorted(total_views.items(), key=lambda item: item[1], reverse=True))
        
        for i in sorted_map:
            if sorted_map[i] == maximum:
                ans.append([i, ids[id_map[i]]])
                
        return ans

// Leetcode 1743 - Restore the Array From Adjacent Pairs

class Solution1743:
    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:
        closest = {}
        start = 0
        restored = []
        
        for i in adjacentPairs:
            if i[0] not in closest:
                closest[i[0]] = [i[1]]
            else:
                closest[i[0]].append(i[1])
            
            if i[1] not in closest:
                closest[i[1]] = [i[0]]
            else:
                closest[i[1]].append(i[0])
        
        for i in closest:
            if len(closest[i]) == 1:
                start = i
                break
                
        restored.append(start)
        restored.append(closest[start][0])
        prev = start
        curr = closest[start][0]
        
        while len(restored) != len(closest):
            if closest[curr][0] != prev:
                restored.append(closest[curr][0])
                prev = curr
                curr = closest[curr][0]
            else:
                restored.append(closest[curr][1])
                prev = curr
                curr = closest[curr][1]
            
        return restored

// Leetcode 1865 - Finding Pairs With a Certain Sum

class FindSumPairs1865:

    def __init__(self, nums1: List[int], nums2: List[int]):
        self.nums1 = nums1
        self.nums2 = nums2
        self.map = {}
        
        for i in self.nums2:
            if i not in self.map:
                self.map[i] = 1
            else:
                self.map[i] += 1
        

    def add(self, index: int, val: int) -> None:
        self.map[self.nums2[index]] -= 1
        
        self.nums2[index] += val
        
        if self.nums2[index] not in self.map:
            self.map[self.nums2[index]] = 1
        else:
            self.map[self.nums2[index]] += 1

    def count(self, tot: int) -> int:
        temp = 0
        for i in self.nums1:
            if tot - i in self.map:
                temp += self.map[tot - i]
        return temp


# Your FindSumPairs object will be instantiated and called as such:
# obj = FindSumPairs(nums1, nums2)
# obj.add(index,val)
# param_2 = obj.count(tot)

// Leetcode 2336 - Smallest Number in Infinite Set

class SmallestInfiniteSet {
    TreeSet<Integer> sorted;

    public SmallestInfiniteSet() {
        sorted = new TreeSet<Integer>();
        for(int i=1; i < 1001; i++){
            sorted.add(i);
        }
    }
    
    public int popSmallest() {
        int min = 0;
        for(int i : sorted){
            min = i;
            break;
        }
        sorted.remove(min);
        return min;
    }
    
    public void addBack(int num) {
        sorted.add(num);
    }
}

// Leetcode 2352 - Equal Row and Column Pairs

class Solution2352:
    def equalPairs(self, grid: List[List[int]]) -> int:
        rows = {}
        columns = {}
        
        temp = ""
        equal = 0
        
        for i in grid:
            for j in i:
                temp += str(j)
                temp += ','
            if temp not in rows:
                rows[temp] = 1
            else:
                rows[temp] += 1
            temp = ""
        
        for i in range(len(grid[0])):
            for j in range(len(grid)):
                temp += str(grid[j][i])
                temp += ','
            if temp not in columns:
                columns[temp] = 1
            else:
                columns[temp] += 1
            temp = ""
            
        for i in columns:
            if i in rows:
                equal += columns[i]*rows[i]
        
        return equal

// Leetcode 2364 - Count Number of Bad Pairs

class Solution2364:
    def countBadPairs(self, nums: List[int]) -> int:
        total = len(nums)*(len(nums)-1)/2
        good = 0
        temp = 0
        pairs = {}
        
        for i in range(len(nums)):
            if nums[i] - i not in pairs:
                pairs[nums[i] - i] = 1
            else:
                pairs[nums[i] - i] += 1
        
        for i in pairs:
            good += int(pairs[i]*(pairs[i]-1)/2)
        
        return int(total - good)

// Leetcode 1721 - Swapping Nodes in a Linked List

class Solution1721:
    def __init__(self):
        self.nodes = []
    
    def iterate(self, head):
        if head != None:
            self.nodes.append(head)
            self.iterate(head.next)
            
    def swapNodes(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        self.iterate(head)
        
        for i in self.nodes:
            i.next = None
        
        temp = self.nodes[k-1]
        self.nodes[k-1] = self.nodes[len(self.nodes)-k]
        self.nodes[len(self.nodes)-k] = temp
        
        for i in range(len(self.nodes)-1):
            self.nodes[i].next = self.nodes[i+1]
        
        return self.nodes[0]

// Leetcode 2571 - Minimum Operations to Reduce an Integer to 0

class Solution2571:
    def minOperations(self, n: int) -> int:
        power_of_two = 1
        while power_of_two <= n:
            if n == power_of_two:
                return 1
            power_of_two *= 2
        return min(self.minOperations(n-power_of_two//2)+1, self.minOperations(power_of_two-n)+1)

class Solution2571 {
    public int minOperations(int n) {
        return Integer.bitCount(n ^ (n * 3));
    }
}

// Leetcode 946 - Validate Stack Sequences

class Solution946 {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        Stack<Integer> stack = new Stack<Integer>();
        int pops = 0;

        for(int i=0; i < pushed.length; i++){
            stack.push(pushed[i]);
            while( pops < popped.length && stack.size() > 0 && popped[pops] == stack.peek() ){
                pops++;
                stack.pop();
            }
        }
        return (pops==popped.length)?true:false;
    }
}

// Leetcode 1296 - Divide Array in Sets of K Consecutive Numbers

class Solution1296:
    def isPossibleDivide(self, nums: List[int], k: int) -> bool:
        
        if len(nums) % k != 0:
            return False
        
        val = 0
        result = 0
        values = {}
        current = 0
        
        for i in nums:
            if i not in values:
                values[i] = 1
            else:
                values[i] += 1
                
        values = dict(sorted(values.items()))
        
        for i in values:
            if result == len(nums)/k:
                return True
            current = i
            if current in values and values[current] > 0:
                while current in values and values[current] > 0 and val < k:
                    current += 1
                    val += 1
                if val == k:
                    for j in range(current-k+1, current):
                        if values[j] < values[current-k]:
                            return False
                        values[j] -= values[current-k]
                    result += values[current-k]
                else:
                    return False
                val = 0
        
        if result == len(nums)/k:
            return True
                    
        return False

// Leetcode 846 - Hand of Straights

class Solution846:
    def isPossibleDivide(self, nums: List[int], k: int) -> bool:
        
        if len(nums) % k != 0:
            return False
        
        val = 0
        result = 0
        values = {}
        current = 0
        
        for i in nums:
            if i not in values:
                values[i] = 1
            else:
                values[i] += 1
                
        values = dict(sorted(values.items()))
        
        for i in values:
            if result == len(nums)/k:
                return True
            current = i
            if current in values and values[current] > 0:
                while current in values and values[current] > 0 and val < k:
                    current += 1
                    val += 1
                if val == k:
                    for j in range(current-k+1, current):
                        if values[j] < values[current-k]:
                            return False
                        values[j] -= values[current-k]
                    result += values[current-k]
                else:
                    return False
                val = 0
        
        if result == len(nums)/k:
            return True
                    
        return False
    
    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:
        return self.isPossibleDivide(hand, groupSize)

// Leetcode 2043 - Simple Bank System

class Bank {
    HashMap<Integer, Long> map = new HashMap<Integer, Long>();
    public Bank(long[] balance) {
        for(int i=0; i < balance.length; i++){
            map.put(i+1, balance[i]);
        }
    }
    
    public boolean transfer(int account1, int account2, long money) {
        if( !map.containsKey(account1) || !map.containsKey(account2) ) return false;
        if( map.get(account1) < money ) return false;
        map.put(account2, map.get(account2) + money);
        map.put(account1, map.get(account1) - money);
        return true;
    }
    
    public boolean deposit(int account, long money) {
        if( !map.containsKey(account) ) return false;
        map.put(account, map.get(account) + money);
        return true;
    }
    
    public boolean withdraw(int account, long money) {
        if( !map.containsKey(account) || map.get(account) < money ) return false;
        map.put(account, map.get(account) - money);
       return true; 
    }
}

/**
 * Your Bank object will be instantiated and called as such:
 * Bank obj = new Bank(balance);
 * boolean param_1 = obj.transfer(account1,account2,money);
 * boolean param_2 = obj.deposit(account,money);
 * boolean param_3 = obj.withdraw(account,money);
 */

// Leetcode 746 - Min Cost Climbing Stairs

class Solution746 {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[n];
        dp[n-1] = cost[n-1];
        dp[n-2] = cost[n-2];
        for(int i=n-3; i > -1; i--){
            dp[i] = cost[i] + Math.min(dp[i+1], dp[i+2]);
        }
        return Math.min(dp[0], dp[1]);
    }
}

// Leetcode 1807 - Evaluate the Bracket Pairs of a String

class Solution1807:
    def evaluate(self, s: str, knowledge: List[List[str]]) -> str:
        pair, ans, replacement, i = {}, "", "", 0
        
        for j in knowledge:
            pair[j[0]] = j[1]
        
        while i < len(s):
            if s[i] == '(':
                i += 1
                while i < len(s) and s[i] != ')':
                    replacement += s[i]
                    i += 1
                if replacement not in pair:
                    ans += '?'
                else:
                    ans += pair[replacement]
                replacement = ""
                
            else:
                ans += s[i]
            i += 1
        
        return ans

// Leetcode 2579 - Count Total Number of Colored Cells

class Solution2579:
    def coloredCells(self, n: int) -> int:
        return max(1, 2 * n**2 - 2 * n + 1)

// Leetcode 2375 - Construct Smallest Number From DI String

class Solution:
    
    def convert_to_number(self, x):
        num = ""
        for i in x:
            num += str(i)
        
        return int(num)
    
    def smallestNumber(self, pattern: str) -> str:
        
        digits = []
        steps = 0
        minimum = 987654321
        
        for i in range(len(pattern)+1):
            digits.append(i+1)
            
        digits = permutations(digits)
        
        for i in digits:
            for j in range(len(pattern)):
                if pattern[j] == 'I' and i[j] < i[j+1]:
                    steps += 1
                elif pattern[j] == 'D' and i[j] > i[j+1]:
                    steps += 1
                else:
                    break
                    
            if steps == len(pattern):
                minimum = min(minimum, self.convert_to_number(i))
            
            steps = 0
                
        return str(minimum)

// Leetcode 77 - Combinations

class Solution77:
    def combine(self, n: int, k: int) -> List[List[int]]:
        numbers = []
        combined = []
        temp = []
        
        for i in range(1, n+1):
            numbers.append(i)
            
        for i in list(combinations(numbers, k)):
            for j in i:
                temp.append(j)
            combined.append(temp)
            temp = []
            
        return combined

// Leetcode 1567 - Maximum Length of Subarray With Positive Product

class Solution1567 {
    public int getMaxLen(int[] nums) {
        int positive = 1;
        int streak = 0;
        int windowStart = 0;
        int maxLen = 0;
        
        for(int i=0; i < nums.length; i++){
            if( nums[i] < 0 ) nums[i] = -1;
            else if( nums[i] > 0 ) nums[i] = 1; 
        }

        for(int i=0; i < nums.length; i++){
            if( nums[i] == 0 ){ windowStart = i+1; positive = 1; streak = 0; }
            else{
                if( nums[i] > 0 ) streak++;
                else streak = 0;
                positive *= nums[i];
                if( positive > 0 ) maxLen = Math.max(maxLen, i - windowStart + 1);
                maxLen = Math.max(maxLen, streak);
            }
        }
        
        positive = 1;
        streak = 0;
        windowStart = nums.length-1;
        
        for(int i=nums.length-1; i > -1; i--){
            if( nums[i] == 0 ){ windowStart = i-1; positive = 1; streak = 0; }
            else{
                if( nums[i] > 0 ) streak++;
                else streak = 0;
                positive *= nums[i];
                if( positive > 0 ) maxLen = Math.max(maxLen, windowStart - i + 1);
                maxLen = Math.max(maxLen, streak);
            }
        }
        return maxLen;
    }
}

// Leetcode 714 - Best Time to Buy and Sell Stock with Transaction Fee

class Solution714 {
    public int maxProfit(int[] prices, int fee) {
       if( prices.length < 2 ) return 0;
       int buy = prices[0];
        int profit = 0;
        for(int i=1; i < prices.length; i++){
            if( prices[i] < buy ){
                buy = prices[i];
            }
            else if( prices[i] - buy > fee ){
                profit += prices[i] - buy - fee;
                buy = prices[i] - fee;
            }
        }
        return profit;
    }
}

// Leetcode 2161 - Partition Array According to Given Pivot

class Solution2161:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        equal = []
        less = []
        greater =[]
        ans = []
        
        for i in nums:
            if i == pivot:
                equal.append(i)
            elif i < pivot:
                less.append(i)
            else:
                greater.append(i)
        
        for i in less:
            ans.append(i)
        
        for i in equal:
            ans.append(i)
        
        for i in greater:
            ans.append(i)
        
        return ans

// Leetcode 2295 - Replace Elements in an Array

class Solution2295 {
    public int[] arrayChange(int[] nums, int[][] operations) {
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        HashMap<Integer, Integer> ans = new HashMap<Integer, Integer>();
        for(int i=0; i < operations.length; i++){
            if( !map.containsKey(operations[i][0]) ) map.put(operations[i][1], operations[i][0]);
            else{
                map.put(operations[i][1], map.get(operations[i][0]));
                map.remove(operations[i][0]);
            }
        }
        for(int key : map.keySet()){
            ans.put(map.get(key), key);
        }
        for(int i=0; i < nums.length; i++){
            if( ans.containsKey(nums[i]) ) nums[i] = ans.get(nums[i]);
        }
        return nums;
    }
}

// Leetcode 1726 - Tuple with Same Product

class Solution1726:
    def tupleSameProduct(self, nums: List[int]) -> int:
        tuples = {}
        same_product = 0
        
        for i in range(len(nums)):
            for j in range(i+1, len(nums)):
                if nums[i] != nums[j]:
                    if nums[i] * nums[j] not in tuples:
                        tuples[nums[i]*nums[j]]  = 1
                    else:
                        tuples[nums[i]*nums[j]] += 1
        
        for i in tuples:
            same_product += tuples[i] * (tuples[i] - 1) * 4
        
        return same_product

// Leetcode 684 - Replace Words

class Solution684:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        words = set()
        state = 0
        temp = ""
        ans = ""
        
        for i in dictionary:
            words.add(i)
        
        sentence = sentence.split()
        
        for i in range(len(sentence)):
            for j in range(len(sentence[i])):
                temp += sentence[i][j]
                if temp in words:
                    state = 1
                    ans += temp
                    if i != len(sentence) - 1:
                        ans += ' '
                    break
                    
            if state == 0:
                ans += sentence[i]
                if i != len(sentence) - 1:
                    ans += ' '
            
            temp = ""
            state = 0
            
        return ans

// Leetcode 554 - Brick Wall

class Solution554 {
    public int leastBricks(List<List<Integer>> wall) {
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        int width = 0;
        int min = wall.size();
        for(int i=0; i < wall.size(); i++){
            for(int j=0; j < wall.get(i).size()-1; j++){
                if( !map.containsKey(wall.get(i).get(j) + width) ) map.put(wall.get(i).get(j)+width, 1);
                else map.put(wall.get(i).get(j)+width, map.get(wall.get(i).get(j)+width)+1);
                width += wall.get(i).get(j);
            }
            width = 0;
        }
        for(int i : map.keySet()){
            min = Math.min(min, wall.size() - map.get(i));
        }
        return min;
    }
}

// Leetcode 817 - Linked List Components

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution817:
    
    def __init__(self):
        self.nodes = []
        self.temp = set()
        
    def iterate(self, head):
        if head != None:
            self.nodes.append(head.val)
            self.iterate(head.next)
            
    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:
        components, j, start = 0, 0, 0
        self.iterate(head)
        
        for i in nums:
            self.temp.add(i)
        
        while j < len(self.nodes):
            start = j
            while j < len(self.nodes) and self.nodes[j] in self.temp:
                j += 1
            if j - start != 0:
                components += 1
            j += 1
        
        return components

// Leetcode 1695 - Maximum Erasure Value

class Solution1695 {
    public int maximumUniqueSubarray(int[] nums) {
        int sum = 0;
        int max = 0;
        int index = -1;
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        HashMap<Integer, Integer> prefix = new HashMap<Integer, Integer>();
        for(int i=0; i < nums.length; i++){
            sum += nums[i];
            prefix.put(i, sum);
        }
        sum = 0;
        for(int i=0; i < nums.length; i++){
            if( map.containsKey(nums[i]) ){
                if( map.get(nums[i]) > index ){
                    if( index == -1 )  sum -= prefix.get(map.get(nums[i]));
                    else  sum -= (prefix.get(map.get(nums[i])) - prefix.get(index));
                    index = map.get(nums[i]);
                }
                if( sum < 0 ) sum = 0;
            }
            sum += nums[i];
            map.put(nums[i], i);
            max = Math.max(max, sum);
        }
        return max;
    }
}

// Leetcode 1418 - Display Table of Food Orders in a Restaurant

class Solution1418:
    def __init__(self):
        self.foods_map = {}
        self.customers = {}
    
    def displayTable(self, orders: List[List[str]]) -> List[List[str]]:
        table = []
        foods = set()
        row_one = ["Table"]
        
        for i in orders:
            foods.add(i[2])
        
        foods = sorted(list(foods))
        
        for i in range(len(foods)):
            self.foods_map[foods[i]] = i+1
            row_one.append(foods[i])
        
        for i in orders:
            i[1] = int(i[1])
            if i[1] not in self.customers:
                self.customers[i[1]] = [0]*len(row_one)
            self.customers[i[1]][self.foods_map[i[2]]] += 1
        
        table.append(row_one)
        
        self.customers = collections.OrderedDict(sorted(self.customers.items()))
        
        for i in self.customers:
            self.customers[i][0] = str(i)
            for j in range(1, len(self.customers[i])):
                self.customers[i][j] = str(self.customers[i][j])
            table.append(self.customers[i])
        
        return table

// Leetcode 46 - Permutations

class Solution46:
    def recursive_call(self, n, prefix, used):
        if n == 0:
            ans = []
            j = 0
            if prefix not in self.set:
                while j < len(prefix):
                    if prefix[j] != ',':
                        if prefix[j] == '-':
                            j += 1
                            if j < len(prefix) and prefix[j+1] != ',':
                                ans.append(-1*int(prefix[j]+prefix[j+1]))
                                j += 1
                            else:
                                ans.append(-1*int(prefix[j]))
                        else:
                            if j < len(prefix) and prefix[j+1] != ',':
                                ans.append(int(prefix[j]+prefix[j+1]))
                                j += 1
                            else:
                                ans.append(int(prefix[j]))
                    j += 1
                self.ans.append(ans)
                self.set.add(prefix)
        else:
            for i in self.alphabet:
                if str(i) not in used:
                    used.add(str(i))
                    self.recursive_call(n-1, prefix + str(i) + ',', used)
                    used.remove(str(i))
        
    def permutation(self, n):
        self.recursive_call(n, "", set())

    def permute(self, nums: List[int]) -> List[List[int]]:
        self.ans = []
        self.set = set()
        self.alphabet = nums
        self.permutation(len(nums))
        return self.ans

// Leetcode 47 - Permutations II

class Solution47:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        permutations = itertools.permutations(nums)
        permute = []
        unique = set()
        ans = []
        
        for i in permutations:
            unique.add(i)
        
        for i in unique:
            for j in i:
                permute.append(j)
            ans.append(permute)
            permute = []
        
        return ans

// Leetcode 1817 - Finding Users Active Minutes

class Solution1817:
    def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:
        log_set = set()
        user_map = {}
        answer = [0]*k
        
        for i in logs:
            log_set.add((i[0], i[1]))
        
        for i in log_set:
            if i[0] not in user_map:
                user_map[i[0]] = 1
            else:
                user_map[i[0]] += 1
        
        for i in user_map:
            if user_map[i] > 0 and user_map[i] < k+1:
                answer[user_map[i]-1] += 1
        
        return answer

// Leetcode 797 - All Paths From Source to Target

class Solution797:
    def __init__(self):
        self.graph = {}
        self.paths = []
        
    def find_paths(self, node, target, path):
        if node == target:
            self.paths.append(path)
        elif node in self.graph:
            for neighbour in self.graph[node]:
                copy = path.copy()
                copy.append(neighbour)
                self.find_paths(neighbour, target, copy)
                
    
    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        for i in range(len(graph)):
            for j in graph[i]:
                if i not in self.graph:
                    self.graph[i] = [j]
                else:
                    self.graph[i].append(j)
        self.find_paths(0, len(graph)-1, [0])
        return self.paths

// Leetcode 1557 - Minimum Number of Vertices to Reach All Nodes

class Solution1557:
    def __init__(self):
        self.graph = {}
        
    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:
        vertices = []
        for i in edges:
            if i[0] not in self.graph:
                self.graph[i[0]] = [i[1]]
            else:
                self.graph[i[0]].append(i[1])
                    
        paired = set()
        for i in self.graph:
            for j in self.graph[i]:
                paired.add(j)
        
        for i in range(n):
            if i not in paired:
                vertices.append(i)
        
        return vertices

// Leetcode 1476 - Subrectangle Queries

class SubrectangleQueries:

    def __init__(self, rectangle: List[List[int]]):
        self.rectangle = rectangle

    def updateSubrectangle(self, row1: int, col1: int, row2: int, col2: int, newValue: int) -> None:
        for i in range(row1, row2+1):
            for j in range(col1, col2+1):
                self.rectangle[i][j] = newValue

    def getValue(self, row: int, col: int) -> int:
        return self.rectangle[row][col]


# Your SubrectangleQueries object will be instantiated and called as such:
# obj = SubrectangleQueries(rectangle)
# obj.updateSubrectangle(row1,col1,row2,col2,newValue)
# param_2 = obj.getValue(row,col)

// Leetcode 2592 - Maximize Greatness of an Array

class Solution2592:
    def maximizeGreatness(self, nums: List[int]) -> int:
        greatness = 0
        left_over = 0
        new_list = nums.copy()
        new_greatest, start, freq = [], 0, {}
        new_list.sort()
        
        for i in range(len(new_list)):
            if new_list[i] != new_list[start]:
                new_greatest.append(new_list[start])
                start = i
            
            if new_list[i] not in freq:
                freq[new_list[i]] = 1
            else:
                freq[new_list[i]] += 1
    
        new_greatest.append(new_list[len(new_list)-1])
        print(new_greatest, freq)
        
        for i in range(len(new_greatest)-1):
            if freq[new_greatest[i]] < freq[new_greatest[i+1]]:
                greatness += freq[new_greatest[i]]
                if left_over > 0:
                    if freq[new_greatest[i+1]] - freq[new_greatest[i]] > left_over:
                        greatness += left_over
                        left_over = 0
                    else:
                        greatness += freq[new_greatest[i+1]] - freq[new_greatest[i]]
                        left_over -= freq[new_greatest[i+1]] - freq[new_greatest[i]]
            else:
                left_over += freq[new_greatest[i]] - freq[new_greatest[i+1]]
                greatness += freq[new_greatest[i+1]]
        
        return greatness

// Leetcode 16 - 3Sum Closest

class Solution16:
    def binary_search(self, nums, target, i):
        closest = float('inf')
        closest_sum = 0
        a = 0
        b = len(nums)-1
        while a < b:
            if a == i:
                a += 1
            elif b == i:
                b -= 1
            
            if a < b:
                pass
            else:
                break
                
            if abs(target - nums[a] - nums[b]) < closest and a != i and b != i:
                closest = abs(target - nums[a] - nums[b])
                closest_sum = nums[a] + nums[b]
            if nums[a] + nums[b] == target and a != i and b != i:
                return target
            elif nums[a] + nums[b] > target:
                b -= 1
            else:
                a += 1
        return closest_sum
            
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        closest = float('inf')
        closest_sum = 0
        two_sum = 0
        nums.sort()
        for i in range(len(nums)):
            two_sum = self.binary_search(nums, target - nums[i], i)
            if abs(target - nums[i] - two_sum) < closest:
                closest = abs(target - nums[i] - two_sum)
                closest_sum = nums[i] + two_sum
        return closest_sum

// Leetcode 15 - 3Sum

class Solution15:
    def __init__(self):
        self.triples = set()
        
    def two_sum(self, nums, target, index):
        ints = set()
        ans = []
        c = []
        for i in range(len(nums)):
            if i != index:
                if target - nums[i] in ints:
                    c = sorted([-1*target, nums[i], target-nums[i]])
                    if (c[0], c[1], c[2]) not in self.triples:
                        ans.append([target-nums[i], nums[i]])
                        self.triples.add((c[0], c[1], c[2]))
                    ints.remove(target-nums[i])
                else:
                    ints.add(nums[i])

        return ans
            
        
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        ans = []
        three = []
        for i in range(len(nums)):
            three = self.two_sum(nums, 0 - nums[i], i)
            for j in three:
                ans.append([nums[i], j[0], j[1]])
        
        return ans

// Leetcode 2316 - Count Unreacable Pairs of Nodes in an Undirected Graph

class Solution2316:
    def __init__(self):
        self.groups = []
        self.graph = {}
        
    def calculate_pairs(self):
        score = 0
        group_sum = 0
        
        for i in self.groups:
            group_sum += i
            
        for i in self.groups:
            group_sum -= i
            score += i * group_sum
        
        return score
    
    def bfs(self, n, graph):
        visited, node, queue, group = set(), 0, [0], 0
        
        for i in range(n):
            if i not in visited:
                visited.add(i)
                queue = [i]
                group += 1
                while queue:        
                    node = queue.pop(0)     
                    if node in graph:          
                        for neighbour in graph[node]:                
                            if neighbour not in visited:   
                                group += 1
                                queue.append(neighbour)                    
                                visited.add(neighbour)
                    else:
                        self.groups.append(1)
                        group = 0
            if group != 0:
                self.groups.append(group)
            group = 0
                        
    def countPairs(self, n: int, edges: List[List[int]]) -> int:
        for i in edges:
            if i[0] not in self.graph:
                self.graph[i[0]] = [i[1]]
            else:
                self.graph[i[0]].append(i[1])
            
            if i[1] not in self.graph:
                self.graph[i[1]] = [i[0]]
            else:
                self.graph[i[1]].append(i[0])
                
        self.bfs(n, self.graph)
        return self.calculate_pairs()

// Leetcode 881 - Boats to Save People

class Solution881 {
    public int numRescueBoats(int[] people, int limit) {
        Arrays.sort(people);
        int a = 0;
        int b = people.length-1;
        int boats = 0;
        HashSet<Integer> set = new HashSet<Integer>();
        while( a < b ){
            if( people[a] + people[b] <= limit ){ boats++; set.add(a); set.add(b); a++; b--; }
            else if( people[b] <= limit ){ boats++; b--; }
        }
        if( !set.contains(a) ) boats++;
        return boats;
    }
}

// Leetcode 1344 - Angle Between Hands of a Clock 

class Solution1344 {
    public double angleClock(int hour, int minutes) {
        double minutesAngle = (6 * (double)minutes) % 360;
        double hourAngle = (hour * 30) % 360 + (double)minutes / 2;
        double angle = Math.abs(minutesAngle - hourAngle);
        if( 360 - angle < angle ) return 360-angle;
        return angle;
    }
}

// Leetcode 1637 - Widest Vertical Area Between Two Points Containing No Points

class Solution1637 {
    public int maxWidthOfVerticalArea(int[][] points) {
        int maxWidth = 0;
        Arrays.sort(points, (int[] o1, int[] o2) -> o1[0] - o2[0]);
        for(int i=0; i < points.length-1; i++){
            maxWidth = Math.max(maxWidth, points[i+1][0]-points[i][0]);
        }
        return maxWidth;
    }
}

// Leetcode 2090 - K Radius Subarray Averages

class Solution2090 {
    public int[] getAverages(int[] nums, int k) {
        if( k == 0 ) return nums;
        long sum = 0;
        int windowStart = 0;
        int[] averages = new int[nums.length];
        HashMap<Integer, Long> map = new HashMap<Integer, Long>();
        for(int i=0; i < nums.length; i++){
            sum += nums[i];
            if( i - windowStart == k - 1 ){
                map.put(i - k + 1, sum);
                sum -= nums[windowStart];
                windowStart++;
            }
        }
        for(int i=0; i < nums.length; i++){
            if( map.containsKey(i - k) && map.containsKey(i+1) ){
                averages[i] = (int)((map.get(i - k) + map.get(i+1) + nums[i]) / (2*k + 1));
            }
            else averages[i] = -1;
        }
        return averages;
    }
}

// Leetcode 1305 - All Elements in Two Binary Search Trees

class Solution1305 {
    int a = 0;
    int b = 0;
    List<Integer> b1 = new ArrayList<Integer>();
    List<Integer> b2 = new ArrayList<Integer>();
    List<Integer> elements = new ArrayList<Integer>();
    public void search1(TreeNode root){
        if( root != null ){
            search1(root.left);
            b1.add(root.val);
            search1(root.right);
        }
    }
    public void search2(TreeNode root){
        if( root != null ){
            search2(root.left);
            b2.add(root.val);
            search2(root.right);
        }
    } 
    public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {
        search1(root1);
        search2(root2);
        while( a < b1.size() && b < b2.size() ){
            if( b1.get(a) < b2.get(b) ){
                elements.add(b1.get(a));
                a++;
            }
            else if( b1.get(a) > b2.get(b) ){
                elements.add(b2.get(b));
                b++;
            }
            else{
                elements.add(b1.get(a));
                elements.add(b1.get(a));
                a++; b++;
            }
        }
        if( a < b1.size() ){for(int i=a; i < b1.size(); i++){ elements.add(b1.get(i)); }}
        if( b < b2.size() ){for(int i=b; i < b2.size(); i++){ elements.add(b2.get(i)); }}
        return elements;
    }
}

// Leetcode 1306 - Jump Game III

class Solution1306 {
    boolean canreach = false;
    HashSet<Integer> dp = new HashSet<Integer>();
    public void recursive(int[] nums, int i){
        if( i > -1 && i < nums.length && !dp.contains(i) ){
            if( nums[i] == 0 ) canreach = true;
            dp.add(i);
            recursive(nums, i + nums[i]);
            recursive(nums, i - nums[i]);
        }
    }
    public boolean canReach(int[] arr, int start) {
        recursive(arr, start);
        return canreach;
    }
}

// Leetcode 1525 - Number of Good Ways to Split a String

class Solution1525 {
    HashSet<Character> set = new HashSet<Character>();
    HashMap<Integer, Integer> front = new HashMap<Integer, Integer>();
    HashMap<Integer, Integer> back = new HashMap<Integer, Integer>();
    public int numSplits(String s) {
        int splits = 0;
        for(int i=0; i < s.length()-1; i++){
            set.add(s.charAt(i));
            front.put(i, set.size());
        }
        set.clear();
        for(int i=s.length()-1; i > 0; i--){
            set.add(s.charAt(i));
            back.put(i, set.size());
        }
        for(int i=0; i < s.length()-1; i++){
            if( front.get(i) == back.get(i+1) ) splits++;
        }
        return splits;
    }
}

// Leetcode 1706 - Where Will the Ball Fall

class Solution1706:
    def find_path(self, column, grid):
        for i in range(len(grid)):
            if grid[i][column] == 1:
                if column == len(grid[0])-1:
                    return -1
                else:
                    if grid[i][column+1] == -1:
                        return -1
                    else:
                        column += 1
            else:
                if column == 0:
                    return -1
                else:
                    if grid[i][column-1] == 1:
                        return -1
                    else:
                        column -= 1
        return column
                
        
    def findBall(self, grid: List[List[int]]) -> List[int]:
        answer = []
        for i in range(len(grid[0])):
            answer.append(self.find_path(i, grid))
        return answer

// Leetcode 646 - Maximum Length of Pair Chain

// Non-DP Solution

class Solution646 {
    public int findLongestChain(int[][] pairs) {
        int longest = 0;
        int curr = 0;
        int start = 0;
        Arrays.sort(pairs, (int[] o1, int[] o2) -> o1[1] - o2[1]);
        for(int i=0; i < pairs.length; i++){
            while( i < pairs.length && pairs[i][0] > pairs[start][1] ){
                start = i;
                i++;
                curr++;
            }
            longest = Math.max(longest, curr+1);
        }
        return longest;
    }
}

// DP (LIS) Solution

class Solution646LIS {
    public int findLongestChain(int[][] pairs) {
        int n = pairs.length;
        int LC = 1;
        int[] dp = new int[n];
        Arrays.sort(pairs, (int[] o1, int[] o2) -> o1[0] - o2[0]);

        dp[n-1] = 1;

        for(int i=n-2; i > -1; i--){
            for(int j=i+1; j < n; j++){
                if( pairs[i][1] < pairs[j][0] && dp[j] + 1 > dp[i] ) dp[i] = dp[j] + 1;
            }
            LC = Math.max(LC, dp[i]);
        }

        return LC;
    }
}

// Leetcode 6328 - Find the Substring With Maximum Cost

class Solution6328 {
    HashMap<Character, Integer> c = new HashMap<Character, Integer>();
    public int maxSubArray(int[] nums) {
        int sum=0, max=nums[0];
        for(int i=0;i<nums.length;i++){
            sum+=nums[i];
            max=Math.max(max,sum);
            if(sum<0){
                sum=0;
            }
        }
        return max;
    }
    public int maximumCostSubstring(String s, String chars, int[] vals) {
        int[] nums = new int[s.length()];
        for(int i=0; i < chars.length(); i++){
            c.put(chars.charAt(i), vals[i]);
        }
        for(int i=0; i < s.length(); i++){
            if( !c.containsKey(s.charAt(i)) ) nums[i] = s.charAt(i) - 96;
            else nums[i] = c.get(s.charAt(i));
        }
        return Math.max(0, maxSubArray(nums));
    }
}

// Leetcode 2300 - Successful Pairs of Spells and Potions

class Solution2300 {
    public int binarySearch(int[] nums, long target, int spell){
        int low = 0;
        int high = nums.length-1;
        int mid = 0;
        long product = 0;
        while( low <= high ){
            mid = (high+low)/2;
            product = (long)spell * (long)nums[mid];
            if( product >= target ){
                if( mid == 0 ) return nums.length;
                else if( (long)spell * (long)nums[mid-1] < target ) return nums.length - mid;
                else high = mid-1;
            }
            else if( product < target ) low = mid+1;
        }
        return 0;
    }
    public int[] successfulPairs(int[] spells, int[] potions, long success) {
        Arrays.sort(potions);
        int[] pairs = new int[spells.length];
        for(int i=0; i < spells.length; i++){
            pairs[i] = binarySearch(potions, success, spells[i]);
        }
        return pairs;
    }
}

// Leetcode 1492 - The kth Factor of n

class Solution1492 {
    public int kthFactor(int n, int k) {
        for(int i=1; i < n+1; i++){
            if( n % i == 0 ) k--;
            if( k == 0 ) return i;
        }
        return -1;
    }
}

// Leetcode 2610 - Convert an Array Into a 2D Array With Conditions

class Solution2610:
    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        freq = {}
        matrix = []
        
        for i in nums:
            if i not in freq:
                freq[i] = 1
            else:
                freq[i] += 1
                
        for i in freq:
            for j in range(freq[i]):
                if len(matrix) <= j:
                    matrix.append([i])
                else:
                    matrix[j].append(i)
        
        return matrix

// Leetcode 763 - Partition Labels

class Solution763 {
    HashMap<Character, Integer> back = new HashMap<Character, Integer>();
    List<Integer> ans = new ArrayList<Integer>();
    public List<Integer> partitionLabels(String s) {
        int max = -1;
        int prev = 0;
        for(int i=s.length()-1; i > -1; i--){
            if( !back.containsKey(s.charAt(i)) ) back.put(s.charAt(i), i);
        }
        for(int i=0; i < s.length(); i++){
            max = Math.max(max, back.get(s.charAt(i)));
            if( i == max ){
                ans.add(max+1 - prev);
                prev = max+1;
                max = -1;
            }
        }
        return ans;
    }
}

// Leetcode 2405 - Optimal Partition of String

class Solution2405 {
    HashSet<Character> set = new HashSet<Character>();
    public int partitionString(String s) {
        int tot = 0;
        for(int i=0; i < s.length(); i++){
            if( set.contains(s.charAt(i)) ){ set.clear(); tot++; }
            set.add(s.charAt(i));
        }
        return tot+1;
    }
}

// Leetcode 2442 - Count Number of Distinct Integers After Reverse Operations

class Solution2442 {
    public int reverse(int x) {
        long multiply = 1;
        int sign = (x<0)?-1:1;
        long reverse = 0;
        x = Math.abs(x);
        int copy = x;
        while( copy > 0 ){
            copy /= 10;
            multiply *= 10;
        }
        multiply /= 10;
        while( x > 0 ){
            reverse += multiply * (x % 10);
            multiply /= 10;
            x /= 10;
        }
        if( reverse > Integer.MAX_VALUE ) reverse = 0;
        return sign*((int)reverse);
    }
    public int countDistinctIntegers(int[] nums) {
        HashSet<Integer> set = new HashSet<Integer>();
        for(int i=0; i < nums.length; i++){
            set.add(nums[i]);
            set.add(reverse(nums[i]));
        }
        return set.size();
    }
}

// Leetcode 1347 - Minimum Number of Steps to Make Two Strings Anagram

class Solution1347 {
    public int minSteps(String s, String t) {
        int min = 0;
        HashMap<Character, Integer> map1 = new HashMap<Character, Integer>();
        HashMap<Character, Integer> map2 = new HashMap<Character, Integer>();
        for(int i=0; i < s.length(); i++){
            if( !map1.containsKey(s.charAt(i)) ) map1.put(s.charAt(i), 1);
            else map1.put(s.charAt(i), map1.get(s.charAt(i))+1);
            if( !map2.containsKey(t.charAt(i)) ) map2.put(t.charAt(i), 1);
            else map2.put(t.charAt(i), map2.get(t.charAt(i))+1);
        }
        for(char i : map1.keySet()){
            if( !map2.containsKey(i) ) min += map1.get(i); 
            else if( map1.get(i) > map2.get(i) ) min += map1.get(i) - map2.get(i);
        }
        return min;
    }
}

// Leetcode 2186 - Minimum Number of Steps to Make Two Strings Anagram II

class Solution2186 {
    public int minSteps(String s, String t) {
        int min = 0;
        HashMap<Character, Integer> map1 = new HashMap<Character, Integer>();
        HashMap<Character, Integer> map2 = new HashMap<Character, Integer>();
        for(int i=0; i < s.length(); i++){
            if( !map1.containsKey(s.charAt(i)) ) map1.put(s.charAt(i), 1);
            else map1.put(s.charAt(i), map1.get(s.charAt(i))+1);
        }
        for(int i=0; i < t.length(); i++){
            if( !map2.containsKey(t.charAt(i)) ) map2.put(t.charAt(i), 1);
            else map2.put(t.charAt(i), map2.get(t.charAt(i))+1);
        }
        for(char i : map1.keySet()){
            if( !map2.containsKey(i) ) min += map1.get(i); 
            else if( map1.get(i) > map2.get(i) ) min += map1.get(i) - map2.get(i);
        }
        for(char i : map2.keySet()){
            if( !map1.containsKey(i) ) min += map2.get(i); 
            else if( map2.get(i) > map1.get(i) ) min += map2.get(i) - map1.get(i);
        }
        return min;
    }
}

// Leetcode 1442 - Count Triplets That Can Form Two Arrays of Equal XOR

class Solution1442:
    def countTriplets(self, arr: List[int]) -> int:
        triplets = 0
        xor = 0
        pairs = {}
        for i in range(len(arr)):
            for j in range(i, len(arr)):
                xor ^= arr[j]
                if i not in pairs:
                    pairs[i] = [(xor, j+1)]
                else:
                    pairs[i].append((xor, j+1))
            xor = 0
        for i in pairs:
            for j in pairs[i]:
                if j[1] in pairs:
                    for a in pairs[j[1]]:
                        if a[0] == j[0]:
                            triplets += 1
        return triplets

// Leetcode 1079 - Letter Tile Possibilities

class Solution1079:
    def numTilePossibilities(self, tiles: str) -> int:
        chars = []
        arr = []
        temp = []
        pairs = set()
        ans = 0
        for i in tiles:
            chars.append(i)
        for i in range(1, len(tiles)+1):
            arr = itertools.combinations(chars, i)
            for j in arr:
                if j not in pairs:
                    temp = itertools.permutations(j)
                    for a in temp:
                        if a not in pairs:
                            ans += 1
                        pairs.add(a)
                pairs.add(j)
        return ans

// Leetcode 811 - Subdomain Visit Count

class Solution811:
    def subdomainVisits(self, cpdomains: List[str]) -> List[str]:
        domains = {}
        domain = []
        subdomain = ""
        count = 0
        visits = []
        for i in cpdomains:
            domain = i.split(' ')
            count = int(domain[0])
            domain = domain[1].split('.')
            for j in range(len(domain)-1, -1, -1):
                if j == len(domain)-1:
                    subdomain = domain[j]
                else:
                    subdomain = domain[j] + '.' + subdomain
                if subdomain not in domains:
                    domains[subdomain] = count
                else:
                    domains[subdomain] += count
            subdomain = ""
        for i in domains:
            visits.append(str(domains[i]) + ' ' + i)
        return visits

// Leetcode 2521 - Distinct Prime Factors of Product of Array

class Solution2521 {
    HashSet<Integer> distinct = new HashSet<Integer>();
    List<Integer> primes = new ArrayList<Integer>();
    public void generatePrimes(){
        int factors = 0;
        for(int i=2; i < 999; i++){
            for(int j=1; j < i+1; j++){
                if( i % j == 0 ) factors++;
            }
            if( factors == 2 ) primes.add(i);
            factors = 0;
        }
    }
    public void primeFactorisation(int n){
        for(int i=0; i < primes.size(); i++){
            if( primes.get(i) > n ) break;
            if( n % primes.get(i) == 0 ) distinct.add(primes.get(i)); 
        }
    }
    public int distinctPrimeFactors(int[] nums) {
        generatePrimes();
        for(int i=0; i < nums.length; i++){
            primeFactorisation(nums[i]);
        }
        return distinct.size();
    }
}

// Leetcode 355 - Design Twitter

class Twitter:

    def __init__(self):
        self.following = {}
        self.tweets = []

    def postTweet(self, userId: int, tweetId: int) -> None:
        self.tweets.insert(0, [userId, tweetId])

    def getNewsFeed(self, userId: int) -> List[int]:
        tweets = []

        for i in self.tweets:
            if len(tweets) == 10:
                return tweets
            if i[0] == userId or (userId in self.following and i[0] in self.following[userId]):
                tweets.append(i[1])
        
        return tweets

    def follow(self, followerId: int, followeeId: int) -> None:
        if followerId not in self.following:
            self.following[followerId] = set()
            self.following[followerId].add(followeeId)
        else:
            self.following[followerId].add(followeeId)

    def unfollow(self, followerId: int, followeeId: int) -> None:
        if followerId in self.following and followeeId in self.following[followerId]:
            self.following[followerId].remove(followeeId)

// Leetcode 31 - Next Permutation

class Solution31 {
    public void partSort(int[] arr, int N, int a, int b)
    {
        int l = Math.min(a, b);
        int r = Math.max(a, b);
        Arrays.sort(arr, l, r + 1);
    }
    public void nextPermutation(int[] nums) {
        int[] digits = new int[101];
        int greater = -1;
        for(int i=nums.length-1; i > -1; i--){
            digits[nums[i]] = 1;
            for(int j=nums[i]+1; j < 101; j++){
                if( digits[j] == 1 ){ greater = j; break; }
            }
            if( greater != -1 ){
                for(int j=i+1; j < nums.length; j++){
                    if( nums[j] == greater ){
                        greater = nums[i];
                        nums[i] = nums[j];
                        nums[j] = greater;
                        partSort(nums, nums.length, i+1, nums.length-1);
                        break;
                    }
                }
                break;
            }
        }
        if( greater == -1 ) Arrays.sort(nums);
    }
}

// Leetcode 1010 - Pairs of Songs With Total Durations Divisible by 60

class Solution1010 {
    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
    ArrayList<Integer> multiples = new ArrayList<Integer>();
    public void generate60(){
        int a = 0;
        while( 60 * a < 1000 ){
            multiples.add(60 * a);
            a++;
        }
    }
    public int numPairsDivisibleBy60(int[] time) {
        long pairs = 0;
        for(int i=0; i < time.length; i++){
            if( !map.containsKey(time[i]) ) map.put(time[i], 1);
            else map.put(time[i], map.get(time[i])+1);
        }
        generate60();
        for(int i : map.keySet()){
            for(int j=0; j < multiples.size(); j++){
                if( map.containsKey(multiples.get(j) - i) ){
                    if( multiples.get(j) - i != i ) pairs += (long)map.get(i) * (long)map.get(multiples.get(j) - i);
                    else if( map.get(i) > 1 ) pairs += (long)map.get(i) * ((long)map.get(i)-1);
                }
            }
        }
        return (int)(pairs / 2);
    }
}

// Leetcode 970 - Powerful Integers

class Solution970 {
    public List<Integer> powerfulIntegers(int x, int y, int bound) {
        int p = 0;
        int val = 0;
        List<Integer> ans = new ArrayList<Integer>();
        HashSet<Integer> vals = new HashSet<Integer>();
        if( x == 1 ) vals.add(1);
        else{
            while( Math.pow(x, p) <= 1000000 ){
                vals.add((int)Math.pow(x, p));
                p++;
            }
        }
        p = 0;
        for(int i=0; i <= bound; i++){
            val = 1;
            p = 0;
            if( y == 1 ){ if(vals.contains(i - 1)){ ans.add(i); } }
            else{
            while( i - val >= 0 ){
                if( vals.contains(i - val) ){
                    ans.add(i); break;
                }
                p++;
                val = (int)Math.pow(y, p);
            }
            }
        }
        return ans;
    }
}

// Leetcode 2615 - Sum of Distances

class Solution2615:
    def __init__(self):
        self.map = {}
        
    def distance(self, nums: List[int]) -> List[int]:
        arr = [0]*len(nums)
        prefix = 0
        suffix = 0
        
        for i in range(len(nums)):
            if nums[i] not in self.map:
                self.map[nums[i]] = [i]
            else:
                self.map[nums[i]].append(i)
        
        for i in self.map:
            if len(self.map[i]) == 1:
                arr[self.map[i][0]] = 0
            else:
                print(self.map[i])
                for j in range(len(self.map[i])):
                    arr[self.map[i][j]] = self.map[i][j] * j - prefix
                    prefix += self.map[i][j]
                for j in range(len(self.map[i])-1, -1, -1):
                    arr[self.map[i][j]] += suffix + self.map[i][j] * (j - len(self.map[i])+1)
                    suffix += self.map[i][j]
                prefix = 0
                suffix = 0
    
        return arr

// Leetcode 1170 - Compare Strings by Frequency of the Smallest Character

class Solution1170 {
    public int search(int[] nums, int target){
        int low = 0;
        int high = nums.length-1;
        int mid = 0;
        while( low <= high ){
            mid = (high+low)/2;
            if( nums[mid] == target ) low = mid+1;
            else if( nums[mid] < target ) low = mid+1;
            else{
                if( mid == 0 ) return nums.length;
                else if( nums[mid-1] <= target ) return nums.length - mid;
                else high = mid-1;
            }
        }
        return 0;
    }
    public int[] numSmallerByFrequency(String[] queries, String[] words) {
        int[] smallest = new int[words.length];
        int[] ans = new int[queries.length];
        int min = 123;
        int frequency = 0;
        for(int i=0; i < words.length; i++){
            for(int j=0; j < words[i].length(); j++){
                min = Math.min(min, words[i].charAt(j));
            }
            for(int j=0; j < words[i].length(); j++){
                if( words[i].charAt(j) == min ) frequency++;
            }
            smallest[i] = frequency;
            frequency = 0;
            min = 123;
        }
        min = 123;
        Arrays.sort(smallest);
        for(int i=0; i < queries.length; i++){
            for(int j=0; j < queries[i].length(); j++){
                min = Math.min(min, queries[i].charAt(j));
            }
            for(int j=0; j < queries[i].length(); j++){
                if( queries[i].charAt(j) == min ) frequency++;
            }
            ans[i] = search(smallest, frequency);
            frequency = 0;
            min = 123;
        }
        return ans;
    }
}

// Leetcode 274 - H-Index

class Solution274 {
    public int search(int[] nums, int target){
        int low = 0;
        int high = nums.length-1;
        int mid = 0;
        while( low <= high ){
            mid = (high+low)/2;
            if( nums[mid] == target ){
                if( mid > 0 && nums[mid-1] < target ) return nums.length-mid;
                else if( mid == 0 ) return nums.length;
                high = mid-1;
            }
            else if( nums[mid] < target ){
                if( mid < nums.length-1 && nums[mid+1] > target ) return nums.length-1-mid;
                low = mid+1;
            }
            else{
                if( mid == 0 ) return nums.length;
                high = mid-1;
            }
        }
        return 0;
    }
    public int hIndex(int[] citations) {
        int maxhIndex = 0;
        Arrays.sort(citations);
        for(int i=0; i < 1000; i++){
            if( search(citations, i) < i ) return maxhIndex;
            else maxhIndex = i;
        }
        if( citations[0] > 0 ) return 1;
        return 0;
    }
}

// Leetcode 147 - Insertion Sort List

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution147:
    def __init__(self):
        self.map = {}
        
    def iterate(self, head):
        if head != None:
            if head.val not in self.map:
                self.map[head.val] = [head]
            else:
                self.map[head.val].append(head)
            self.iterate(head.next)
            
    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        nodes = []
        self.iterate(head)
        self.map = dict(sorted(self.map.items()))
        for i in self.map:
            for j in self.map[i]:
                j.next = None
                nodes.append(j)
        for i in range(len(nodes)-1):
            nodes[i].next = nodes[i+1]
        return nodes[0]

// Leetcode 71 - Simplify Path

class Solution71 {
    public String simplifyPath(String path) {
        String target = "";
        String ans = "";
        int start = 0;
        int period = 0;
        for(int i=path.length()-1; i > -1; i--){
            start = i;
            if( path.charAt(i) == '/' ){
                while( i > -1 && path.charAt(i) == '/' ) i--;
                target += '/';
            }
            else if( path.charAt(i) == '.' ){
                while( i > -1 && path.charAt(i) == '.' ) i--;
                if( i > -1 && path.charAt(i) != '/' ){
                    i = start;
                    while( i > -1 && path.charAt(i) != '/' ){
                        if( period == 0 ) target += path.charAt(i);
                        i--;
                    }
                if( period > 0 ) period--;
                }
                else{
                if( start - i > 1 ){
                    if( start - i == 2 ) period++;
                    else{
                        for(int j=0; j < start-i; j++) target += '.';
                    }
                }
                }
            }
            else{
                while( i > -1 && path.charAt(i) != '/' ){
                    if( period == 0 ) target += path.charAt(i);
                    i--;
                }
                if( period > 0 ) period--;
            }
            i++;
        }
        target = new StringBuilder(target).reverse().toString();
        for(int i=0; i < target.length(); i++){
            if( target.charAt(i) == '/' ){
                while( i < target.length() && target.charAt(i) == '/' ) i++;
                if( i != target.length() ) ans += '/';
                i--;
            }
            else ans += target.charAt(i);
        }
        if( ans.length() == 0 ) return "/";
        return ans;
    }
}

// Leetcode 875 - Koko Eating Bananas

class Solution875 {
    public int score(int[] piles, int k){
        if( k == 0 ) return Integer.MAX_VALUE;
        int hours = 0;
        for(int i=0; i < piles.length; i++){
            if( piles[i] % k == 0 ) hours += piles[i] / k;
            else hours += 1 + piles[i] / k;
        }
        return hours;
    }
    public int binarySearch(int[] piles, int low, int high, int h, double target){
        int k = (low+high)/2;
        int low_hours = 0;
        int high_hours = 0;
        while( low <= high ){
            k = (low+high)/2;
            low_hours = score(piles, k-1);
            high_hours = score(piles, k);
            //System.out.println(k + " " + high_hours + " " + low_hours);
            if( high_hours == h ){
                if( low_hours > h ) return k;
                high = k-1;
            }
            else if( high_hours < h ){
                if( low_hours > h ) return k;
                high = k-1;
                if( low >= high ){
                    high = low;
                    low = k-1;
                }
            }
            else low = k+1;
        }
        return 0;
    }
    public int minEatingSpeed(int[] piles, int h) {
        double bananas = 0;
        int max = piles[0];
        int min = piles[0];
        for(int i=0; i < piles.length; i++){
            bananas += piles[i];
            max = Math.max(max, piles[i]);
            min = Math.min(min, piles[i]);
        }
        if( piles.length == h ) return max;
        return binarySearch(piles, 1, max, h, bananas);
    }
}

// Leetcode 2368  - Reachable Nodes With Restrictions

class Solution2368:
    def __init__(self):
        self.max = 0
    
    def dfs(self, graph, node, path_length, visited, restricted_set):
        visited.add(node)
        self.max = len(visited)
        if node in graph:
            for neighbour in graph[node]:
                if neighbour not in visited and neighbour not in restricted_set:
                    self.dfs(graph, neighbour, path_length+1, visited, restricted_set)
            
    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:
        graph = {}
        for i in edges:
            if i[0] not in graph:
                graph[i[0]] = [i[1]]
            else:
                graph[i[0]].append(i[1])
            
            if i[1] not in graph:
                graph[i[1]] = [i[0]]
            else:
                graph[i[1]].append(i[0])
        self.dfs(graph, 0, 1, set(), set(restricted))
        return self.max

// Leetcode 222 - Count Complete Tree Nodes

class Solution222 {
    public int countNodes(TreeNode root) {
        if( root == null ) return 0;
        int nodes = 0;
        ArrayList<TreeNode> current = new ArrayList<TreeNode>();
        ArrayList<TreeNode> current_two = new ArrayList<TreeNode>();
        current.add(root);
        while( current.size() != 0 ){
            while( current.size() != 0 ){
                nodes++;
                if( current.get(0).left != null ) current_two.add(current.get(0).left);
                if( current.get(0).right != null ) current_two.add(current.get(0).right);
                current.remove(current.get(0));
            }
            while( current_two.size() != 0 ){
                current.add(current_two.get(0));
                current_two.remove(current_two.get(0));
            }
        }
        return nodes;
    }
}

// Leetcode 6334 - Find the Score of All Prefixes of an Array

class Solution6334:
    def findPrefixScore(self, nums: List[int]) -> List[int]:
        arr = []
        prefix = {}
        score = 0
        maximum = 0
        
        for i in range(len(nums)):
            maximum = max(maximum, nums[i])
            prefix[i] = maximum
            
        for i in range(len(nums)):
            arr.append(nums[i] + prefix[i] + score)
            score += nums[i] + prefix[i]
        
        return arr

// Leetcode 2641 - Cousins in Binary Tree II

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution2641 {
    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
    public TreeNode replaceValueInTree(TreeNode root) {
        int depth = 0;
        int sum = 0;
        ArrayList<TreeNode> a = new ArrayList<TreeNode>();
        ArrayList<TreeNode> b = new ArrayList<TreeNode>();
        a.add(root);
        while( a.size() != 0 ){
            while( a.size() != 0 ){
                sum += a.get(0).val;
                if( a.get(0).left != null ) b.add(a.get(0).left);
                if( a.get(0).right != null ) b.add(a.get(0).right);
                a.remove(a.get(0));
            }
            map.put(depth, sum);
            depth++;
            sum = 0;
            while( b.size() != 0 ){
                a.add(b.get(0));
                b.remove(b.get(0));
            }
        }
        int left = 0;
        depth = 1;
        a.add(root);
        while( a.size() != 0 ){
            while( a.size() != 0 ){
                if( a.get(0).left != null ){
                    left = a.get(0).left.val;
                    if( a.get(0).right != null ) a.get(0).left.val = map.get(depth) - a.get(0).right.val - a.get(0).left.val;
                    else a.get(0).left.val = map.get(depth) - a.get(0).left.val;
                    b.add(a.get(0).left);
                }
                if( a.get(0).right != null ){
                    if( a.get(0).left != null ) a.get(0).right.val = map.get(depth) - left - a.get(0).right.val;
                    else a.get(0).right.val = map.get(depth) - a.get(0).right.val;
                    b.add(a.get(0).right);
                }
                a.remove(a.get(0));
            }
            depth++;
            while( b.size() != 0 ){
                a.add(b.get(0));
                b.remove(b.get(0));
            }
        }
        root.val = 0;
        if( root.right != null ) root.right.val = 0;
        if( root.left != null ) root.left.val = 0;
        return root;
    }
}

// Leetcode 2396 - Strictly Palindromic Number

class Solution2396 {
    public boolean isStrictlyPalindromic(int n) {
        return false;
    }
}

// Leetcode 447 - Number of Boomerangs

class Solution447:
    def distance(self, p1, p2):
        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)
        
    def numberOfBoomerangs(self, points: List[List[int]]) -> int:
        if len(points) == 1:
            return 0
        
        count = 0
        length = 0
        dist = {}
        tuples = []
        
        for i in range(len(points)):
            for j in range(len(points)):
                if i != j:
                    length = self.distance(points[i], points[j])
                    if i not in dist:
                        dist[i] = {}
                        dist[i][length] = 1
                    else:
                        if length not in dist[i]:
                            dist[i][length] = 1
                        else:
                            dist[i][length] += 1
            
            for j in dist[i]:
                count += dist[i][j] * (dist[i][j]-1)
        return count

// Leetcode 429 - N-ary Tree Level Order Traversal

/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution429 {
    public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        if( root == null ) return ans;
        Node node = null;
        int len = 1;
        Queue<Node> q = new LinkedList<>();
        ArrayList<Integer> a = new ArrayList<Integer>();
        a.add(root.val);
        ans.add(new ArrayList<>(a));
        a.clear();
        q.add(root);
        while( q.size() != 0 ){
            while( q.size() != 0 && len != 0 ){
            node = q.remove();
                for(int i=0; i < node.children.size(); i++){
                    if( node.children.get(i) != null ){
                        a.add(node.children.get(i).val);
                        q.add(node.children.get(i));
                    }
                }
            len--;
            }
            if( a.size() != 0 ) ans.add(new ArrayList<>(a));
            len = a.size();
            a.clear();
        }
        return ans;
    }
}

// Leetcode 733 - Flood Fill

class Solution733:
    def __init__(self):
        self.flooded = set()
        
    def verify(self, val, m, n, a, b, i, j):
        if i < 0 or j < 0 or i == m or j == n or self.image[a][b] != self.image[i][j]:
            return False
        return True
        
    def bfs(self, source_node, color, graph):
        visited = set()
        node = source_node
        visited.add(node)
        self.image[node[0]][node[1]] = color
        queue = [node]

        while queue:
            node = queue.pop(0)
            if node in graph:
                for neighbour in graph[node]:
                    if neighbour not in visited:
                        queue.append(neighbour)
                        visited.add(neighbour)
                        self.image[neighbour[0]][neighbour[1]] = color
        
    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
        self.image = image
        graph = {}
        for i in range(len(image)):
            for j in range(len(image[0])):
                graph[(i, j)] = []
                if self.verify(image[i][j], len(image), len(image[0]), i, j, i-1, j):
                    graph[(i, j)].append((i-1, j))
                if self.verify(image[i][j], len(image), len(image[0]),  i, j, i+1, j):
                    graph[(i, j)].append((i+1, j))
                if self.verify(image[i][j], len(image), len(image[0]),  i, j, i, j-1):
                    graph[(i, j)].append((i, j-1))
                if self.verify(image[i][j], len(image), len(image[0]),  i, j, i, j+1):
                    graph[(i, j)].append((i, j+1))
                    
        self.bfs((sr, sc), color, graph)
        return image

// Leetcode 200 - Number of Islands

class Solution200:
    def __init__(self):
        self.visited = set()
        self.islands = 0
        
    def bfs(self, source_node, graph):
        node = source_node
        self.visited.add(node)
        queue = [node]

        while queue:
            node = queue.pop(0)
            if node in graph:
                for neighbour in graph[node]:
                    if neighbour not in self.visited:
                        queue.append(neighbour)
                        self.visited.add(neighbour)
        
        self.islands += 1
        
    def verify(self, val, m, n, i, j):
        if i < 0 or j < 0 or i == m or j == n or self.grid[i][j] != '1':
            return False
        return True
    
    def numIslands(self, grid: List[List[str]]) -> int:
        self.grid = grid
        graph = {}
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] != '0':
                    graph[(i, j)] = []
                    if self.verify(grid[i][j], len(grid), len(grid[0]), i-1, j):
                        graph[(i, j)].append((i-1, j))
                    if self.verify(grid[i][j], len(grid), len(grid[0]), i+1, j):
                        graph[(i, j)].append((i+1, j))
                    if self.verify(grid[i][j], len(grid), len(grid[0]), i, j-1):
                        graph[(i, j)].append((i, j-1))
                    if self.verify(grid[i][j], len(grid), len(grid[0]), i, j+1):
                        graph[(i, j)].append((i, j+1))
        
        for i in graph:
            if i not in self.visited:
                self.bfs(i, graph)
                
        return self.islands

// Leetcode 1020 - Number of Enclaves

class Solution1020:
    def __init__(self):
        self.visited = set()
        self.cells = 0
        
    def bfs(self, source_node, graph, n, m):
        edge = False
        length = 1
        node = source_node
        self.visited.add(node)
        queue = [node]

        while queue:
            node = queue.pop(0)
            if node in graph:
                if node[0] == 0 or node[1] == 0 or node[0] == n or node[1] == m:
                    edge = True
                for neighbour in graph[node]:
                    if neighbour not in self.visited:
                        length += 1
                        queue.append(neighbour)
                        self.visited.add(neighbour)
        
        if edge == False:
            self.cells += length
        
    def verify(self, val, m, n, i, j):
        if i < 0 or j < 0 or i == m or j == n or self.grid[i][j] == 0:
            return False
        return True
        
    def numEnclaves(self, grid: List[List[int]]) -> int:
        self.grid = grid
        graph = {}
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    graph[(i, j)] = []
                    if self.verify(grid[i][j], len(grid), len(grid[0]), i-1, j):
                        graph[(i, j)].append((i-1, j))
                    if self.verify(grid[i][j], len(grid), len(grid[0]), i+1, j):
                        graph[(i, j)].append((i+1, j))
                    if self.verify(grid[i][j], len(grid), len(grid[0]), i, j-1):
                        graph[(i, j)].append((i, j-1))
                    if self.verify(grid[i][j], len(grid), len(grid[0]), i, j+1):
                        graph[(i, j)].append((i, j+1))
        
        for i in graph:
            if i not in self.visited:
                self.bfs(i, graph, len(grid)-1, len(grid[0])-1)
        return self.cells

// Leetcode 725 - Split Linked List in Parts

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution725:
    def __init__(self):
        self.nodes = []
        
    def iterate(self, node):
        if node != None:
            self.nodes.append(node)
            self.iterate(node.next)
            
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:
        self.iterate(head)
        ans = []
        if k >= len(self.nodes):
            for i in self.nodes:
                i.next = None
                
            for i in range(k-len(self.nodes)):
                self.nodes.append(None)
            
            return self.nodes
        
        temp = len(self.nodes) // k
        start = self.nodes[0]
        length = 1
        diff = len(self.nodes) % k
        print(diff)
        for i in range(len(self.nodes)):
            if diff == 0:
                if length == temp:
                    ans.append(start)
                    if i != len(self.nodes)-1:
                        start = self.nodes[i+1]
                    self.nodes[i].next = None
                    length = 0
            else:
                if length == temp+1:
                    ans.append(start)
                    if i != len(self.nodes)-1:
                        start = self.nodes[i+1]
                    self.nodes[i].next = None
                    diff -= 1
                    length = 0
            length += 1
        return ans

// Leetcode 743 - Network Delay Time

class Solution743:
    def shortestPath(self, node1: int, node2: int, n: int) -> int:
        # Initialize distances to infinity
        distances = [float('inf')] * n

        # Initialize the distance of the source node to 0
        distances[node1] = 0

        # Initialize visited set
        visited = set()

        while node1 not in visited:
            visited.add(node1)

            # Update distances for adjacent nodes
            for neighbor, cost in self.edges[node1]:
                if distances[neighbor] > distances[node1] + cost:
                    distances[neighbor] = distances[node1] + cost

            # Find the next unvisited node with the shortest distance
            min_distance = float('inf')
            for i in range(n):
                if i not in visited and distances[i] < min_distance:
                    node1 = i
                    min_distance = distances[i]

        return -1 if distances[node2] == float('inf') else distances[node2]
    
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        self.edges = [[] for _ in range(n)]
        delay = 0
        
        for i in times:
            self.edges[i[0]-1].append((i[1]-1, i[2]))
            
        for i in range(0, n):
            if i != k-1:
                distance = self.shortestPath(k-1, i, n)
                if distance == -1:
                    return -1
                delay = max(delay, distance)
        
        return delay

// Leetcode 1679 - Max Number of K-Sum Pairs

class Solution1679 {
    public int maxOperations(int[] nums, int k) {
        int ops = 0;
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        for(int i=0; i < nums.length; i++){
            if( !map.containsKey(nums[i]) ) map.put(nums[i], 1);
            else map.put(nums[i], map.get(nums[i])+1);
        }
        for(int i : map.keySet()){
            if( k - i == i ) ops += map.get(i) / 2;
            else if( map.containsKey(k - i) && map.get(k - i) != 0 ){ ops += Math.min(map.get(i), map.get(k - i)); map.put(k - i, 0); }
        }
        return ops;
    }
}

// Leetcode 1711 - Count Good Meals

class Solution1711 {
    public int countPairs(int[] deliciousness) {
        long meals = 0;
        int power = 0;
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        for(int i=0; i < deliciousness.length; i++){
            if( !map.containsKey(deliciousness[i]) ) map.put(deliciousness[i], 1);
            else map.put(deliciousness[i], map.get(deliciousness[i])+1);
        }
        for(int i : map.keySet()){
            for(int j=0; j < 22; j++){
                power = (int)Math.pow(2, j);
                if( power - i == i ) meals += (long)map.get(i) * (long)(map.get(i)-1) / 2;
                else if( map.containsKey(power - i) && map.get(power - i) != 0 ){
                    meals += (long)map.get(i) * (long)map.get(power - i);
                }
            }
            map.put(i, 0);
        }
        return (int)(meals % 1000000007);
    }
}

// Leetcode 1448 - Count Good Nodes in Binary Tree

class Solution1448 {
    int good = 1;
    public void dfs(TreeNode root, int max){
        if( root != null ){
            if( root.left != null ){
                if( max <= root.left.val ) good++;
                dfs(root.left, Math.max(max, root.left.val));
            }
            if( root.right != null ){
                if( max <= root.right.val ) good++;
                dfs(root.right, Math.max(max, root.right.val));
            }
        }
    }
    public int goodNodes(TreeNode root) {
        dfs(root, root.val);
        return good;
    }
}

// Leetcode 1161 - Maximum Level Sum of a Binary Tree

class Solution1161 {
    public int maxLevelSum(TreeNode root) {
        TreeNode node = null;
        int max = root.val;
        int lowLevel = 1;
        int sum = 0;
        int level = 1;
        ArrayList<TreeNode> a = new ArrayList<TreeNode>();
        ArrayList<TreeNode> b = new ArrayList<TreeNode>();
        a.add(root);
        while( a.size() != 0 ){
            while( a.size() != 0 ){
                sum += a.get(0).val;
                if( a.get(0).left != null ) b.add(a.get(0).left);
                if( a.get(0).right != null ) b.add(a.get(0).right);
                a.remove(a.get(0));
            }
            if( sum > max ){
                max = sum;
                lowLevel = level;
            }
            sum = 0;
            level++;
            while( b.size() != 0 ){
                a.add(b.get(0));
                b.remove(b.get(0));
            }
        }
        return lowLevel;
    }
}

// Leetcode 397 - Integer Replacement 

class Solution397:
    def replace(self, dp, n):
        if n in dp:
            return dp[n]
        if n == 1:
            return 0
        else:
            if n % 2 == 0:
                dp[n] = 1 + self.replace(dp, int(n/2))
            else:
                dp[n] = 1 + min(self.replace(dp, n-1), self.replace(dp, n+1))
        
        return dp[n]
            
    def integerReplacement(self, n: int) -> int:
        if n == 1:
            return 0
        dp = {}
        self.replace(dp, n)
        return dp[n]

// Leetcode 172 - Factorial Trailing Zeroes

class Solution172 {
    public int trailingZeroes(int n) {
        int two = 0;
        int five = 0;
        int temp = 0;
        for(int i=1; i <= n; i++){
            for(int j=1; j < n; j++){
                if( i % (int)Math.pow(2, j) != 0 ) break;
                else temp = j;
            }
            two += temp;
            temp = 0;
            for(int j=1; j < n; j++){
                if( i % (int)Math.pow(5, j) != 0 ) break;
                else temp = j;
            }
            five += temp;
            temp = 0;
        }
        return Math.min(two, five);
    }
}

// Leetcode 994 - Rotting Oranges

class Solution994:
    def __init__(self):
        self.time = {}
        
    def bfs(self, source_node, graph, n, m):
        node = source_node
        visited = set()
        visited.add(node)
        queue = [node]

        while queue:
            node = queue.pop(0)
            if node in graph:
                for neighbour in graph[node]:
                    if neighbour not in visited:
                        if neighbour not in self.time:
                            self.time[neighbour] = self.time[node] + 1
                        else:
                            self.time[neighbour] = min(self.time[neighbour], self.time[node]+1)
                        queue.append(neighbour)
                        visited.add(neighbour)
        
    def verify(self, val, m, n, i, j, grid):
        if i < 0 or j < 0 or i == m or j == n or grid[i][j] == 0:
            return False
        return True
        
    def orangesRotting(self, grid: List[List[int]]) -> int:
        graph = {}
        minutes = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] != 0:
                    graph[(i, j)] = []
                    if self.verify(grid[i][j], len(grid), len(grid[0]), i-1, j, grid):
                        graph[(i, j)].append((i-1, j))
                    if self.verify(grid[i][j], len(grid), len(grid[0]), i+1, j, grid):
                        graph[(i, j)].append((i+1, j))
                    if self.verify(grid[i][j], len(grid), len(grid[0]), i, j-1, grid):
                        graph[(i, j)].append((i, j-1))
                    if self.verify(grid[i][j], len(grid), len(grid[0]), i, j+1, grid):
                        graph[(i, j)].append((i, j+1))
        
        for i in graph:
            if grid[i[0]][i[1]] == 2:
                self.time[i] = 0
                self.bfs(i, graph, len(grid)-1, len(grid[0])-1)
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    if (i, j) not in self.time:
                        return -1
                    minutes = max(minutes, self.time[(i, j)])
                    
        return minutes

// Leetcode 863 - All Nodes Distance K in Binary Tree

class Solution863:
    def __init__(self):
        self.graph = {}
        self.nodes = []
        self.visited = set()
    
    def bfs(self, source_node, graph, k):
        node = source_node
        self.visited.add(node)
        queue = [[node, 0]]

        while queue:
            node = queue.pop(0)
            if node[0] in graph:
                for neighbour in graph[node[0]]:
                    if neighbour[0] not in self.visited:
                        neighbour[1] = node[1] + 1
                        if neighbour[1] == k:
                            self.nodes.append(neighbour[0].val)
                        else:
                            queue.append(neighbour)
                            self.visited.add(neighbour[0])
        
    def iterate(self, root):
        if root != None:
            if root.left != None:
                self.graph[root].append([root.left,0])
                self.graph[root.left] = [[root,0]]
            if root.right != None:
                self.graph[root].append([root.right,0])
                self.graph[root.right] = [[root,0]]
            self.iterate(root.left)
            self.iterate(root.right)
        
    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:
        if k == 0:
            return [target.val]
        self.graph[root] = []
        self.iterate(root)
        self.bfs(target, self.graph, k)
        return self.nodes

// Leetcode 670 - Maximum Swap

class Solution {
    ArrayList<Integer> ans = new ArrayList<Integer>();
    public void split(int num){
        while( num > 0 ){
            ans.add(num % 10);
            num /= 10;
        }
    }
    public int maximumSwap(int num) {
        if( num == 0 ) return 0;
        int[] greater = new int[10];
        int a = -1;
        int b = -1;
        int sum = 0;
        split(num);
        Collections.reverse(ans);
        greater[ans.get(ans.size()-1)] = ans.size()-1;
        for(int i=ans.size()-2; i > -1; i--){
            if( greater[ans.get(i)] == 0 ) greater[ans.get(i)] = i;
            for(int j=ans.get(i)+1; j < 10; j++){
                if( greater[j] != 0  ){ a = i; b = greater[j]; }
            }
        }
        if( a == -1 ) return num;
        int c = 1;
        for(int i=ans.size()-1; i > -1; i--){
            if( i == a ) sum += ans.get(b) * c;
            else if( i == b ) sum += ans.get(a) * c;
            else sum += ans.get(i) * c;
            c *= 10;
        }
        return sum;
    }
}

// Leetcode 1685 - Sum of Absolute Difference in a Sorted Array

class Solution1685 {
    public int[] getSumAbsoluteDifferences(int[] nums) {
        int[] result = new int[nums.length];
        int sum = 0;
        for(int i=0; i < nums.length; i++){
            result[i] = i * nums[i] - sum;
            sum += nums[i];
        }
        sum = 0;
        for(int i=nums.length-1; i > -1; i--){
            result[i] += sum - (nums.length - 1 - i) * nums[i];
            sum += nums[i];
        }
        return result;
    }
}

// Leetcode 477 - Total Hamming Distance

class Solution477 {
    int max = 0;
    HashMap<Integer, Integer> one = new HashMap<Integer, Integer>();
    HashMap<Integer, Integer> zero = new HashMap<Integer, Integer>();
    public void length(int num) {
        int[] binary = new int[35];
        int id = 0;
        while (num > 0) {
            binary[id++] = num % 2;
            num = num / 2;
        }
        max = Math.max(max, id);
    }
    public void dTb(int num){
        int[] binary = new int[35];
        int id = 0;
        while (num > 0) {
            binary[id++] = num % 2;
            num = num / 2;
        }
        for(int i=max-1; i >= 0; i--){
            if( i > id - 1 ){
                if( !zero.containsKey(i) ) zero.put(i, 1);
                else zero.put(i, zero.get(i)+1);
            }
            else{
                if( binary[i] == 1 ){
                    if( !one.containsKey(i) ) one.put(i, 1);
                    else one.put(i, one.get(i)+1);
                }
                else{
                    if( !zero.containsKey(i) ) zero.put(i, 1);
                    else zero.put(i, zero.get(i)+1);
                }
            }
        }
    }
    public int totalHammingDistance(int[] nums) {
        int sum = 0;
        for(int i=0; i < nums.length; i++){ 
            length(nums[i]); 
        }
        for(int i=0; i < nums.length; i++){
            dTb(nums[i]);
        }
        for(int i : one.keySet()){
            if( zero.containsKey(i) ){
                if( one.get(i) != 0 && zero.get(i) != 0 ) sum += one.get(i) * zero.get(i);
                zero.remove(i);
            }
        }
        for(int i : zero.keySet()){
            if( one.containsKey(i) ){
                if( one.get(i) != 0 && zero.get(i) != 0 ) sum += one.get(i) * zero.get(i);
            }
        }
        return sum;
    }
}

// Leetcode 2195 - Append K Integers With Minimal Sum

class Solution2195 {
    public long minimalKSum(int[] nums, int k) {
        long sum = 0;
        int og = 0;
        Arrays.sort(nums);
        if( nums[0] != 1 ){
            if( nums[0] - 1 > k ) return (long)(k + 1) * (long)(k) / 2;
            else{
                sum += (long)(nums[0] + 1) * (long)nums[0] / 2 - nums[0];
                k -= nums[0] - 1;
            }
        }
        for(int i=0; i < nums.length-1; i++){
            if( nums[i+1] - nums[i] != 1 && nums[i] != nums[i+1]){
                if( nums[i+1] - nums[i] > k ){
                    return sum + (long)(nums[i] + k) * (long)(nums[i] + k + 1) / 2 - (long)(nums[i] + 1)*(long)nums[i] / 2;
                }
                else{
                    sum += (long)(nums[i+1]) * (long)(nums[i+1] - 1) / 2 - (long)(nums[i] + 1)*(long)nums[i] / 2;
                    k -= nums[i+1] - nums[i] - 1;
                }
                
            }
            if( k == 0 ) return sum;
        }
        int n = nums.length-1;
        sum += (long)(nums[n] + k + 1) * (long)(nums[n] + k) / 2 - (long)nums[n] * (long)(nums[n] + 1) / 2;
        return sum;
    }
}

// Leetcode 216 - Smallest Value of the Rearranged Number

class Solution216 {
    int[] digit = new int[10];
    int min = 9;
    public void split(long num){
        while( num > 0 ){
            if( num % 10 != 0 && num % 10 < min ) min = (int)(num % 10);    
            digit[(int)(num % 10)]++;
            num /= 10;
        }
    }
    public long smallestNumber(long num) {
        long ten = 1;
        long ans = 0;
        int x = (num<0)?-1:1;
        num *= x;
        split(num);
        if( x == -1 ){
            for(int i=0; i < 10; i++){
                for(int j=0; j < digit[i]; j++){ 
                    ans += i * ten; 
                    ten *= 10;
                }
            }
        }
        else{   
            digit[min]--;
            for(int i=9; i > -1; i--){
                for(int j=0; j < digit[i]; j++){
                    ans += i * ten;
                    ten *= 10;
                }
            }
            if( digit[min] > -1 ) ans += min * ten;
        }
        return ans * x;
    }
}

// Leetcode 988 - Smallest String Starting From Leaf

class Solution988:
    def __init__(self):
        self.nodes = []
        
    def dfs(self, root, path):
        if root != None:
            if root.left == None and root.right == None:
                self.nodes.append(path[::-1])
            else:
                if root.left != None:
                    self.dfs(root.left, path+chr(root.left.val+97))
                if root.right != None:
                    self.dfs(root.right, path+chr(root.right.val+97))
                
    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:
        self.dfs(root, ""+chr(root.val+97))
        s = sorted(self.nodes)
        return s[0]

// Leetcode 2657 - Find the Prefix Common Array of Two Arrays

class Solution2657 {
    public int[] findThePrefixCommonArray(int[] A, int[] B) {
        int[] C = new int[A.length];
        HashSet<Integer> a = new HashSet<Integer>();
        HashSet<Integer> b = new HashSet<Integer>();
        int common = 0;
        for(int i=0; i < A.length; i++){
            a.add(A[i]);
            b.add(B[i]);
            if( a.contains(B[i]) ) common++;
            if( A[i] != B[i] && b.contains(A[i]) ) common++;
            C[i] = common;
        }
        return C;
    }
}

// Leetcode 2342 - Max Sum of a Pair With Equal Sum of Digits

class Solution2342:
    def split(self, n):
        s = 0
        while n > 0:
            s += n % 10
            n = int(n / 10)
        return s
    
    def maximumSum(self, nums: List[int]) -> int:
        digit = {}
        s = 0
        maximum = -1
        for i in nums:
            s = self.split(i)
            if s not in digit:
                digit[s] = [i, -1]
            else:
                if digit[s][1] == -1:
                    digit[s][1] = i
                else:
                    if i > digit[s][0]:
                        if digit[s][0] > digit[s][1]:
                            digit[s][1] = digit[s][0]
                        digit[s][0] = i
                    elif i > digit[s][1]:
                        digit[s][1] = i
        
        for i in digit:
            if digit[i][1] != -1:
                maximum = max(maximum, digit[i][0] + digit[i][1])
        
        return maximum

// Leetcode 508 - Most Frequent Subtree Sum

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution508:
    def __init__(self):
        self.dp = {}
    
    def dfs(self, root):
        if root == None:
            return 0
        else:
            if root in self.dp:
                return self.dp[root]
            self.dp[root] = root.val + self.dfs(root.left) + self.dfs(root.right)
            return self.dp[root]
        
    def findFrequentTreeSum(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        freq = {}
        maximum = 0
        self.dfs(root)
        for i in self.dp:
            if self.dp[i] not in freq:
                freq[self.dp[i]] = 1
            else:
                freq[self.dp[i]] += 1
            maximum = max(maximum, freq[self.dp[i]])
    
        for i in freq:
            if freq[i] == maximum:
                ans.append(i)
        return ans

// Leetcode 1846 - Maximum Element After Decreasing and Rearranging 

class Solution1846 {
    public int maximumElementAfterDecrementingAndRearranging(int[] arr) {
        Arrays.sort(arr);
        arr[0] = 1;
        int max = 1;
        for(int i=0; i < arr.length-1; i++){
            if( arr[i+1] - arr[i] > 1 ) arr[i+1] = arr[i]+1;
            max = Math.max(max, arr[i+1]);
        }
        return max;
    }
}

// Leetcode 1829 - Maximum XOR for Each Query

class Solution1829 {
    public int max(int num, int bits){
        int[] binary = new int[bits];
        int id = 0;
        int k = 0;
        int maximum = (int)Math.pow(2, bits);
        while (num > 0) {
            binary[id++] = num % 2;
            num = num / 2;
        }
        for(int i=0; i < bits; i++){
            if( binary[i] == 0 ){
                if( Math.pow(2, i) + k <= maximum ) k += Math.pow(2, i);
                else return k;
            }
        }
        return k;
    }
    public int[] getMaximumXor(int[] nums, int maximumBit) {
        int[] answer = new int[nums.length];
        int xor = 0;
        for(int i=0; i < nums.length; i++){
            xor ^= nums[i];
            answer[nums.length-1-i] = max(xor, maximumBit);
        }
        return answer;
    }
}

// Leetcode 2671 - Frequency Tracker

class FrequencyTracker {
    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
    HashMap<Integer, Integer> freq = new HashMap<Integer, Integer>();
    public FrequencyTracker() {
        
    }
    
    public void add(int number) {
        if( !map.containsKey(number) ) map.put(number, 1);
        else map.put(number, map.get(number)+1);
        if( freq.containsKey(map.get(number)-1) ){
            freq.put(map.get(number)-1, freq.get(map.get(number)-1)-1);
            if( freq.get(map.get(number)-1) < 1 ) freq.put(map.get(number)-1, 0);
        }
        
        if( !freq.containsKey(map.get(number)) ) freq.put(map.get(number), 1);
        else freq.put(map.get(number), freq.get(map.get(number))+1);
    }
    
    public void deleteOne(int number) {
        if( map.containsKey(number) && map.get(number) > 0 ){
            freq.put(map.get(number), freq.get(map.get(number))-1);
            if( freq.get(map.get(number)) < 1 ) freq.put(map.get(number), 0);
            if( !freq.containsKey(map.get(number)-1) ) freq.put(map.get(number)-1, 1);
            else freq.put(map.get(number)-1, freq.get(map.get(number)-1)+1);
            map.put(number, map.get(number)-1);
            if( map.get(number) < 1 ) map.remove(number);
        }
    }
    
    public boolean hasFrequency(int frequency) {
        if( !freq.containsKey(frequency) || freq.get(frequency) == 0 ) return false;
        return true;
    }
}

/**
 * Your FrequencyTracker object will be instantiated and called as such:
 * FrequencyTracker obj = new FrequencyTracker();
 * obj.add(number);
 * obj.deleteOne(number);
 * boolean param_3 = obj.hasFrequency(frequency);
 */

// Leetcode 2672 - Number of Adjacent Elements With the Same Color

class Solution2672:
    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:
        nums = [0]*n
        answer = []
        j = 0
        adj = 0
        
        for i in range(len(queries)):
            j = queries[i][0]
            if nums[j] != 0:
                if j-1 > -1 and nums[j-1] != 0:
                    if nums[j-1] == nums[j]:
                        if nums[j-1] != queries[i][1]:
                            adj -= 1
                    elif nums[j-1] == queries[i][1]:
                        adj += 1
                if j+1 < n and nums[j+1] != 0:
                    if nums[j+1] == nums[j]:
                        if nums[j+1] != queries[i][1]:
                            adj -= 1
                    elif nums[j+1] == queries[i][1]:
                        adj += 1
            else:
                if j-1 > -1 and nums[j-1] != 0 and nums[j-1] == queries[i][1]:
                    adj += 1
                if j+1 < n and nums[j+1] != 0 and nums[j+1] == queries[i][1]:
                    adj += 1
            nums[j] = queries[i][1]
            answer.append(adj)

        return answer

// Leetcode 1471 - The k Strongest Values in an Array

class Solution1471 {
    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
    public int[] getStrongest(int[] arr, int k) {
        Arrays.sort(arr);
        int m = arr[(arr.length-1)/2];
        int[] s = new int[arr.length];
        int[] ans = new int[k];
        for(int i=0; i < arr.length; i++){
            s[i] = Math.abs(arr[i]-m);
        }
        Arrays.sort(s);
        for(int i=s.length-1; i > s.length-1-k; i--){
            if( !map.containsKey(s[i]) ) map.put(s[i], 1);
            else map.put(s[i], map.get(s[i])+1);
        }
        int j = 0;
        int n = 0;
        for(int i=s.length-1; i > -1; i--){
            n = Math.abs(arr[i]-m);
            if( map.containsKey(n) && map.get(n) > 0 ){
                ans[j] = arr[i];
                j++;
                map.put(n, map.get(n)-1);
            }
        }
        return ans;
    }
}

// Leetcode 2428 - Maximum Sum of an Hourglass

class Solution2428 {
    public int maxSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int max = 0;
        int glass = 0;
        for(int i=0; i < m-2; i++){
            for(int j=0; j < n-2; j++){
                glass = grid[i][j] + grid[i][j+1] + grid[i][j+2] + grid[i+1][j+1] + grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2];
                max = Math.max(max, glass);
                glass -= grid[i][j] + grid[i+1][j+1] + grid[i+2][j];
            }
            glass = 0;
        }
        return max;
    }
}

// Leetcode 2487 - Remove Nodes From Linked List

class Solution2487 {
    int max = 0;
    public ListNode reverseList(ListNode head){
        ListNode prev = null;
        ListNode current = head;
        ListNode next = null;
        while (current != null) {
            next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        return prev;
    }
    public void iterate(ListNode head, ListNode prev){
        if( head != null ){
            if( head.val < max ){
                prev.next = head.next;
                iterate(head.next, prev);
            }
            else{
                max = Math.max(max, head.val);
                iterate(head.next, head);
            }
        }
    }
    public ListNode removeNodes(ListNode head) {
        ListNode list = reverseList(head);
        iterate(list, list);
        return reverseList(list);
    }
}

// Leetcode 2684 - Maximum Number of Moves in a Grid

class Solution2684:
    def __init__(self):
        self.m, self.n, self.max_moves = 0, 0, 0
        self.dp = {} 
    
    def verify(self, i, j):
        if i < 0 or j < 0 or i >= self.m or j >= self.n:
            return False
        return True 
    
    def dfs(self, grid, i, j):
        if self.verify(i-1, j+1):
            if grid[i][j] < grid[i-1][j+1]:
                if (i-1, j+1) not in self.dp:
                    if (i,j) not in self.dp:
                        self.dp[(i,j)] = 1 + self.dfs(grid, i-1, j+1)
                    else:
                        self.dp[(i,j)] = max(self.dp[(i,j)], 1 + self.dfs(grid, i-1, j+1))
                else:
                    if (i,j) not in self.dp:
                        self.dp[(i,j)] = 1 + self.dp[(i-1, j+1)] 
                    else:
                        self.dp[(i,j)] = max(self.dp[(i,j)], 1 + self.dp[(i-1, j+1)])
        
        if self.verify(i, j+1):
            if grid[i][j] < grid[i][j+1]:
                if (i, j+1) not in self.dp:
                    if (i,j) not in self.dp:
                        self.dp[(i,j)] = 1 + self.dfs(grid, i, j+1)
                    else:
                        self.dp[(i,j)] = max(self.dp[(i,j)], 1 + self.dfs(grid, i, j+1))
                else:
                    if (i,j) not in self.dp:
                        self.dp[(i,j)] = 1 + self.dp[(i, j+1)] 
                    else:
                        self.dp[(i,j)] = max(self.dp[(i,j)], 1 + self.dp[(i, j+1)])
                    
        if self.verify(i+1, j+1):
            if grid[i][j] < grid[i+1][j+1]:
                if (i+1, j+1) not in self.dp:
                    if (i,j) not in self.dp:
                        self.dp[(i,j)] = 1 + self.dfs(grid, i+1, j+1)
                    else:
                        self.dp[(i,j)] = max(self.dp[(i,j)], 1 + self.dfs(grid, i+1, j+1))
                else:
                    if (i,j) not in self.dp:
                        self.dp[(i,j)] = 1 + self.dp[(i+1, j+1)] 
                    else:
                        self.dp[(i,j)] = max(self.dp[(i,j)], 1 + self.dp[(i+1, j+1)])

        if (i,j) not in self.dp:
            return 1
        else:
            return self.dp[(i,j)]
    
    def maxMoves(self, grid: List[List[int]]) -> int:
        self.m = len(grid)
        self.n = len(grid[0])
        for i in range(len(grid)):
            self.dfs(grid, i, 0)
            if (i,0) in self.dp:
                self.max_moves = max(self.max_moves, self.dp[(i,0)]-1)
        return self.max_moves

// Leetcode 120 - Triangle

class Solution120:
    def verify(self, i, j, triangle):
        if i < 0 or j < 0 or j >= len(triangle[i]):
            return False
        return True
        
    def dfs(self, dp, triangle, i, j):
        if self.verify(i, j, triangle):
            if (i,j) in dp:
                return dp[(i,j)]
            if i == 0:
                return triangle[i][j]
            if j != 0:
                a = self.dfs(dp, triangle, i-1, j-1)
                if a != 10000000:
                    dp[(i,j)] = a
            a = self.dfs(dp, triangle, i-1, j)
            if a != 10000000:
                if (i,j) not in dp:
                    dp[(i,j)] = a
                else:
                    dp[(i,j)] = min(dp[(i,j)], a)
            if (i,j) in dp:
                dp[(i,j)] += triangle[i][j] 
        
        if (i,j) in dp:
            return dp[(i,j)]
        return 10000000
        
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        if len(triangle) == 1:
            return triangle[0][0]
        dp = {}
        minimum = 10000000
        for i in range(len(triangle[len(triangle)-1])):
            self.dfs(dp, triangle, len(triangle)-1, i)
            minimum = min(minimum, dp[(len(triangle)-1, i)])
        return minimum

// Leetcode 1894 - Find the Student that Will Replace the Chalk

class Solution1894 {
    public int chalkReplacer(int[] chalk, int k) {
        long sum = 0;
        for(int i=0; i < chalk.length; i++) sum += chalk[i];
        if( sum >= k ){
            if( sum == k ) return 0;
            for(int i=0; i < chalk.length; i++){
                k -= chalk[i];
                if( k < 0 ) return i;
            }
        }
        k = (int)((long)k % sum);
        for(int i=0; i < chalk.length; i++){
            k -= chalk[i];
            if( k < 0 ) return i;
        }
        return 0;
    }
}

// Leetcode 2679 - Sum in a Matrix

class Solution2679:
    def matrixSum(self, nums: List[List[int]]) -> int:
        index = 0
        score = 0
        maximum = 0
        
        while len(nums) * len(nums[0]) != 0:
            for i in range(len(nums)):
                for j in range(len(nums[i])):
                    if nums[i][j] > nums[i][index]:
                        index = j
                maximum = max(maximum, nums[i][index])
                nums[i].pop(index)
                index = 0
            score += maximum
            maximum = 0
        
        return score

// Leetcode 2683 - Neighbouring Bitwise XOR

class Solution2683 {
    public boolean doesValidArrayExist(int[] derived) {
        int xor = 0;
        for(int i=0; i < derived.length; i++) xor ^= derived[i];
        if( xor == 0 ) return true;
        return false;   
    }
}

// Leetcode 64 - Minimum Path Sum

class Solution64:
    def __init__(self):
        self.m, self.n, self.min = 0, 0, 4000000
        self.dp = {} 
    
    def verify(self, i, j):
        if i < 0 or j < 0 or i >= self.m or j >= self.n:
            return False
        return True 
    
    def dfs(self, grid, i, j):
        if self.verify(i, j+1):
            if(i, j+1) not in self.dp:
                if (i,j) not in self.dp:
                    self.dp[(i,j)] = grid[i][j] + self.dfs(grid, i, j+1)
                else:
                    self.dp[(i,j)] = min(self.dp[(i,j)], grid[i][j] + self.dfs(grid, i, j+1))
            else:
                if (i,j) not in self.dp:
                    self.dp[(i,j)] = grid[i][j] + self.dp[(i, j+1)]
                else:
                    self.dp[(i,j)] = min(self.dp[(i,j)], grid[i][j] + self.dfs(grid, i, j+1))
    
        if self.verify(i+1, j):
                if(i+1, j) not in self.dp:
                    if (i,j) not in self.dp:
                        self.dp[(i,j)] = grid[i][j] + self.dfs(grid, i+1, j)
                    else:
                        self.dp[(i,j)] = min(self.dp[(i,j)], grid[i][j] + self.dfs(grid, i+1, j))
                else:
                    if (i,j) not in self.dp:
                        self.dp[(i,j)] = grid[i][j] + self.dp[(i+1, j)]
                    else:
                        self.dp[(i,j)] = min(self.dp[(i,j)], grid[i][j] + self.dfs(grid, i+1, j))
                
        if i == self.m-1 and j == self.n-1:
            self.dp[(i,j)] = grid[i][j]
            return grid[i][j]
        elif (i,j) not in self.dp:
            return 4000000
        else:
            return self.dp[(i,j)]
    
    def minPathSum(self, grid: List[List[int]]) -> int:
        self.m = len(grid)
        self.n = len(grid[0])
        for i in range(self.m):
            for j in range(self.n):
                if (i,j) not in self.dp:
                    self.dfs(grid, i, j)
                    self.min = min(self.min, self.dp[(i,j)])
        return self.min

// Leetcode 62 - Unique Paths

class Solution62:
    def verify(self, i, j):
        if i < 0 or j < 0 or i >= self.m or j >= self.n:
            return False
        return True 
    
    def paths(self, m, n):
        if self.verify(m, n):
            if m == self.m-1 and n == self.n-1:
                return 1
            if (m, n) in self.dp:
                return self.dp[(m, n)]
            self.dp[(m, n)] = self.paths(m, n+1) + self.paths(m+1, n)
            return self.dp[(m, n)]  
        return 0
        
    def uniquePaths(self, m: int, n: int) -> int:
        self.dp = {}
        self.m = m
        self.n = n
        self.paths(0,0)
        if (0,0) not in self.dp:
            return 1
        return self.dp[(0,0)]

// Leetcode 63 - Unique Paths II

class Solution63:
    def verify(self, i, j):
        if i < 0 or j < 0 or i >= self.m or j >= self.n:
            return False
        return True 
    
    def paths(self, m, n):
        if self.verify(m, n) and (m, n) not in self.banned:
            if m == self.m-1 and n == self.n-1:
                return 1
            if (m, n) in self.dp:
                return self.dp[(m, n)]
            self.dp[(m, n)] = self.paths(m, n+1) + self.paths(m+1, n)
            return self.dp[(m, n)]  
        return 0
        
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        self.dp = {}
        self.banned = set()
        self.m = len(obstacleGrid)
        self.n = len(obstacleGrid[0])
        for i in range(len(obstacleGrid)):
            for j in range(len(obstacleGrid[0])):
                if obstacleGrid[i][j] == 1:
                    self.banned.add((i,j))
        self.paths(0,0)
        if (0,0) not in self.dp:
            if obstacleGrid[0][0] == 1:
                return 0
            return 1
        return self.dp[(0,0)]

// Leetcode 934 - Shortest Bridge

class Solution934:
    def __init__(self):
        self.visited = set()
        self.g1 = []
        self.g2 = []
        self.state = 0
        self.min_dist = 1000
        
    def bfs(self, source_node, graph):
        node = source_node
        self.visited.add(node)
        queue = [node]

        while queue:
            node = queue.pop(0)
            if self.state == 0:
                if len(graph[node]) != 4:
                    self.g1.append(node)
            else:
                if len(graph[node]) != 4:
                    self.g2.append(node)
            if node in graph:
                for neighbour in graph[node]:
                    if neighbour not in self.visited:
                        queue.append(neighbour)
                        self.visited.add(neighbour)
        
    def verify(self, val, m, n, i, j):
        if i < 0 or j < 0 or i == m or j == n or self.grid[i][j] != 1:
            return False
        return True
    
    def shortestBridge(self, grid: List[List[int]]) -> int:
        self.grid = grid
        graph = {}
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] != 0:
                    graph[(i, j)] = []
                    if self.verify(grid[i][j], len(grid), len(grid[0]), i-1, j):
                        graph[(i, j)].append((i-1, j))
                    if self.verify(grid[i][j], len(grid), len(grid[0]), i+1, j):
                        graph[(i, j)].append((i+1, j))
                    if self.verify(grid[i][j], len(grid), len(grid[0]), i, j-1):
                        graph[(i, j)].append((i, j-1))
                    if self.verify(grid[i][j], len(grid), len(grid[0]), i, j+1):
                        graph[(i, j)].append((i, j+1))
        
        for i in graph:
            if i not in self.visited:
                self.bfs(i, graph)
                self.state = 1
        for i in self.g1:
            for j in self.g2:
                self.min_dist = min(self.min_dist, abs(i[0]-j[0]) + abs(i[1]-j[1])-1)
                if self.min_dist == 1:
                    return 1
        return self.min_dist

// Leetcode 117 - Populating Next Right Pointers in Each Node II

class Solution117 {
    public Node connect(Node root) {
        if( root == null ) return root;
        ArrayList<Node> current = new ArrayList<Node>();
        ArrayList<Node> current_two = new ArrayList<Node>();
        current.add(root);
        while( current.size() != 0 ){
            while( current.size() != 0 ){
                if( current.size() == 1 ) current.get(0).next = null; 
                else current.get(0).next = current.get(1);
                if( current.get(0).left != null ){
                    current_two.add(current.get(0).left);
                }
                if( current.get(0).right != null ){
                    current_two.add(current.get(0).right);
                }
                current.remove(current.get(0));
            }
            while( current_two.size() != 0 ){
                current.add(current_two.get(0));
                current_two.remove(current_two.get(0));
            }
        }
        return root;
    }
}

// Leetcode 1513 - Number of Substrings With Only 1s

class Solution1513 {
    public int numSub(String s) {
        long sum = 0;
        long l = 0;
        for(int i=0; i < s.length(); i++){
            while( i < s.length() && s.charAt(i) == '1' ){
                l++; i++;
            }
            sum += l*(l+1)/2;
            l = 0;
        }
        return (int)(sum % 1000000007);
    }
}

// Leetcode 1381 - Design a Stack With Increment Operation

class CustomStack:

    def __init__(self, maxSize: int):
        self.stack = []
        self.max = maxSize

    def push(self, x: int) -> None:
        if len(self.stack) != self.max:
            self.stack.append(x)

    def pop(self) -> int:
        y = -1
        if len(self.stack) != 0:
            y = self.stack.pop(len(self.stack)-1)
        return y

    def increment(self, k: int, val: int) -> None:
        if k >= len(self.stack):
            for i in range(len(self.stack)):
                self.stack[i] += val 
        else:
            for i in range(0, k):
                self.stack[i] += val


# Your CustomStack object will be instantiated and called as such:
# obj = CustomStack(maxSize)
# obj.push(x)
# param_2 = obj.pop()
# obj.increment(k,val)

// Leetcode 2567 - Minimum Score by Changing Two Elements

class Solution2567 {
    public int minimizeSum(int[] nums) {
        Arrays.sort(nums);
        int score = nums[nums.length-3] - nums[0];
        score = Math.min(score, nums[nums.length-1] - nums[2]);
        return Math.min(score, nums[nums.length-2] - nums[1]);
    }
}

// Leetcode 2707 - Extra Characters in a String

class Solution2707:
    def max_score(self, ranges):
    # Sort the ranges based on ending values
        ranges.sort(key=lambda x: x[1])

        n = len(ranges)
        dp = [0] * n

        # Calculate the maximum sum of scores
        for i in range(n):
            score = ranges[i][1] - ranges[i][0] + 1
            dp[i] = score

            for j in range(i):
                if ranges[j][1] < ranges[i][0]:
                    dp[i] = max(dp[i], dp[j] + score)

        if not dp:
            return 0

        return max(dp)

    def minExtraChar(self, s: str, dictionary: List[str]) -> int:
        g = 0
        l = 0
        f = 0
        ranges = []
        for i in dictionary:
            f = s.find(i, 0, len(s))
            l = 0
            while f != -1:
                ranges.append([f, f+len(i)-1])
                l = s.find(i, l, len(s)) + 1
                f = s.find(i, l, len(s))
        
        print(ranges)
        return len(s) - self.max_score(ranges)

// Leetcode 2708 - Maximum Strength of a Group

class Solution2708:
    def maxStrength(self, nums: List[int]) -> int:
        max_strength = float('-inf')
        n = len(nums)

        for r in range(1, n + 1):
            for subset in combinations(nums, r):
                product = 1
                for num in subset:
                    product *= num
                max_strength = max(max_strength, product)

        return max_strength

class Solution {
    public long maxStrength(int[] nums) {
        long pos = 1;
        long neg = 1;
        long maxMin = 0;
        int zero = 0;
        int greater = 0;
        
        Arrays.sort(nums);
        
        for(int i=0; i < nums.length; i++){
            if( nums[i] < 0 ){
                neg *= nums[i];
                if( maxMin == 0 ) maxMin = neg;
                else maxMin = Math.max(maxMin, neg);
            }
            else if( nums[i] > 0 ){
                pos *= nums[i];
                greater = 1;
            }
            else zero = 1;
        }
        if( greater == 0 ){
            if( zero == 0 ) return maxMin;
            else return Math.max(0, maxMin);
        }
        if( maxMin == 0 ) maxMin = 1;   
        //if( pos * maxMin < 0 && greater == 0 && zero == 1 ) return 0;
        return Math.max(pos, pos * maxMin);
    }
}

// Leetcode 300 - Longest Increasing Subsequence

class Solution300 {
    public int lengthOfLIS(int[] nums) {
        if( nums.length == 1 ) return 1;
        int n = nums.length;
        int LIS = 0;
        int[] dp = new int[n];
        dp[n-1] = 1;
        
        for(int i=n-2; i > -1; i--){
            dp[i] = 1;
            for(int j=i+1; j < n; j++){
                if( nums[i] < nums[j] ) dp[i] = Math.max(dp[i], dp[j] + 1);
            }
            LIS = Math.max(LIS, dp[i]);
        }
        
        return LIS;
    }
}

// Leetcode 1396 - Design Underground System

class UndergroundSystem:

    def __init__(self):
        self.avg = {}
        self.id = {}

    def checkIn(self, id: int, stationName: str, t: int) -> None:
        self.id[id] = [stationName, t]

    def checkOut(self, id: int, stationName: str, t: int) -> None:
        key = self.id[id][0] + '+' + stationName
        if key not in self.avg:
            self.avg[key] = [t - self.id[id][1], 1]
        else:
            self.avg[key][0] += t - self.id[id][1]
            self.avg[key][1] += 1
        
        self.id[id] = [stationName, t]

    def getAverageTime(self, startStation: str, endStation: str) -> float:
        return self.avg[startStation + '+' + endStation][0] / self.avg[startStation + '+' + endStation][1]


# Your UndergroundSystem object will be instantiated and called as such:
# obj = UndergroundSystem()
# obj.checkIn(id,stationName,t)
# obj.checkOut(id,stationName,t)
# param_3 = obj.getAverageTime(startStation,endStation)

// Leetcode 2166 - Design Bitset

class Bitset:

    def __init__(self, size: int):
        self.size = size
        self.ones = 0
        self.zeros = size
        self.flips = {}
        self.total_flips = 0

    def fix(self, idx: int) -> None:
        if idx not in self.flips:
            if self.total_flips % 2 == 0:
                self.ones += 1
                self.zeros -= 1
        elif (self.total_flips + self.flips[idx]) % 2 == 0:
            self.zeros -= 1
            self.ones += 1
        self.flips[idx] = 1 - self.total_flips

    def unfix(self, idx: int) -> None:
        if idx not in self.flips:
            if self.total_flips % 2 != 0:
                self.ones -= 1
                self.zeros += 1
        elif (self.total_flips + self.flips[idx]) % 2 != 0:
            self.ones -= 1
            self.zeros += 1   
        self.flips[idx] = -1 * self.total_flips

    def flip(self) -> None:
        self.total_flips += 1
        c = self.ones
        self.ones = self.zeros
        self.zeros = c

    def all(self) -> bool:
        if self.ones == self.size:
            return True
        return False

    def one(self) -> bool:
        if self.ones > 0:
            return True
        return False

    def count(self) -> int:
        return self.ones

    def toString(self) -> str:
        composition = ""
        for i in range(self.size):
            if i not in self.flips:
                if self.total_flips % 2 == 0:
                    composition += '0'
                else:
                    composition += '1'
            else:
                if (self.total_flips + self.flips[i]) % 2 == 0:
                    composition += '0'
                else:
                    composition += '1'
        
        return composition


# Your Bitset object will be instantiated and called as such:
# obj = Bitset(size)
# obj.fix(idx)
# obj.unfix(idx)
# obj.flip()
# param_4 = obj.all()
# param_5 = obj.one()
# param_6 = obj.count()
# param_7 = obj.toString()

// Leetcode 2280 - Minimum Lines to Represent a Line Chart

class Solution2280:
    def minimumLines(self, stockPrices: List[List[int]]) -> int:
        if len(stockPrices) == 1:
            return 0
        l = 0
        p = sorted(stockPrices, key=lambda x: x[0], reverse=False)
        x = p[1][0] - p[0][0]
        y = p[1][1] - p[0][1]
        
        for i in range(len(p)-1):
            
            if (p[i+1][0] - p[i][0]) * y != (p[i+1][1] - p[i][1]) * x:
                l += 1
            
            x = p[i+1][0] - p[i][0]
            y = p[i+1][1] - p[i][1] 
            
        return l+1

// Leetcode 2602 - Minimum Operations to Make All Array Elements Equal

class Solution2602 {
    public int searchInsert(int[] nums, int target){
        int start=0, end=nums.length-1, mid=0;
        if(target>nums[end]){
            return end+1;
        }

        if(target<nums[start]){
            return start;
        }

        while(start<=end){
            mid = start + (end-start)/2;
            if(nums[mid]==target){
                return mid;
            }
            if(nums[mid]>target){
                end = mid-1;
            }
            if(nums[mid]<target){
                start = mid+1;
            }
        }
        return start;
    }

    public List<Long> minOperations(int[] nums, int[] queries) {
        long tot = 0;
        long index = 0;
        HashMap<Long, Long> sum = new HashMap<Long, Long>();
        List<Long> answer = new ArrayList<Long>();
        
        Arrays.sort(nums);
        
        for(int i=0; i < nums.length; i++){
            tot += nums[i];
            sum.put((long)i, tot);
        }

        sum.put((long)-1, (long)0);
        for(int i=0; i < queries.length; i++){
            index = (long)searchInsert(nums, queries[i]);
            answer.add(queries[i] * index - sum.get(index-1) + tot - sum.get(index-1) - queries[i] * (nums.length - index));
        }

        return answer;

    }
}

// Leetcode 2125 - Number of Laser Beams in a Bank

class Solution2125:
    def numberOfBeams(self, bank: List[str]) -> int:
        rows = []
        beams =0
        security = 0
        
        for i in bank:
            for j in i:
                if j == '1':
                    security += 1
            if security != 0:
                rows.append(security)
            security = 0
                
        for i in range(len(rows)-1):
            beams += rows[i] * rows[i+1]
        
        return beams

// Leetcode 1090 - Largest Values From Labels

class Solution1090 {
    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
    public int largestValsFromLabels(int[] values, int[] labels, int numWanted, int useLimit) {
        int n = values.length;
        int score = 0;
        int[][] comb = new int[n][2];
        
        for(int i=0; i < n; i++){
            comb[i] = new int[]{values[i], labels[i]};
        }
        
        Arrays.sort(comb, (int[] o1, int[] o2) -> o1[0] - o2[0]);
        
        for(int i=n-1; i > -1; i--){
            if( !map.containsKey(comb[i][1]) ) map.put(comb[i][1], 1);
            else map.put(comb[i][1], map.get(comb[i][1]) + 1);
            
            if( map.get(comb[i][1]) <= useLimit ){ numWanted--;score += comb[i][0]; }
            if( numWanted == 0 ) break;
        }
               
        return score;
    }
}

// Leetcode 1750 - Minimum Length of String After Deleting Similar Ends

class Solution1750 {
    public int minimumLength(String s) {
        int length = s.length();
        int a = 0;
        int b = s.length() - 1;
        char c = '0';
        
        while( a < b ){
            if( s.charAt(a) != s.charAt(b) ) return length;
            c = s.charAt(a);
            while( a < b && s.charAt(a) == c ){
                length--;
                a++;
            }
            while( b > a-1 && s.charAt(b) == c ){
                length--;
                b--;
            }
        }
        return length;
    }
}

// Leetcode 2661 - First Completely Painted Row or Column

class Solution2661:
    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:
        tuples = {}
        rows = {}
        columns = {}
        
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                tuples[mat[i][j]] = (i, j)
        
        for i in range(len(arr)):
            if tuples[arr[i]][0] not in rows:
                rows[tuples[arr[i]][0]] = 1
            else:
                rows[tuples[arr[i]][0]] += 1
            
            if tuples[arr[i]][1] not in columns:
                columns[tuples[arr[i]][1]] = 1
            else:
                columns[tuples[arr[i]][1]] += 1
                
            if rows[tuples[arr[i]][0]] == len(mat[0]) or columns[tuples[arr[i]][1]] == len(mat):
                return i
        
        return len(arr)

// Leetcode 1376 - Time Needed to Inform All Employees

class Solution1376:

    def dfs(self, graph, node, path_length, visited):
        visited.add(node)
        if node in graph:
            for neighbour in graph[node]:
                if neighbour not in visited:
                    self.dfs(graph, neighbour, path_length+self.informTime[neighbour], visited)
        self.total_time = max(self.total_time, path_length)
          
    
    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:
        graph = {}
        self.informTime = informTime
        self.total_time = 0
        self.visited = set()
        
        for i in range(len(manager)):
            if manager[i] != -1:
                if manager[i] not in graph:
                    graph[manager[i]] = [i]
                else:
                    graph[manager[i]].append(i)
        
        self.dfs(graph, headID, informTime[headID], set())
        return self.total_time

// Leetcode 1461 - Check If a String Contains All Binary Codes of Size K

class Solution {
    HashSet<String> set = new HashSet<String>();
    public boolean hasAllCodes(String s, int k) {
        String substring = "";
        for(int i=0; i < s.length()-k+1; i++){
            substring = s.substring(i, i+k);
            set.add(substring);
        }
        if( set.size() == Math.pow(2, k) ) return true;
        return false;
    }
}

// Java has a s.substring(i, j) method which returns the substring from index i to j (inclusive [i, j]) from a string s!

// Leetcode 547 - Number of Provinces

class Solution547:
    def bfs(self, source_node, graph):
        node = source_node
        self.visited.add(node)
        queue = [node]

        while queue:
            node = queue.pop(0)
            if node in graph:
                for neighbour in graph[node]:
                    if neighbour not in self.visited:
                        queue.append(neighbour)
                        self.visited.add(neighbour)
        
        self.provinces += 1
        
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        self.provinces = 0
        self.visited = set()
        graph = {}
        
        for i in range(len(isConnected)):
            for j in range(len(isConnected[0])):
                if i not in graph:
                    graph[i] = []
                if isConnected[i][j] == 1 and i != j:
                    graph[i].append(j)
        
        for i in graph:
            if i not in self.visited:
                self.bfs(i, graph)
        return self.provinces

// Leetcode 1318 - Minimum Flips to Make a OR b Equal to c

class Solution1318 {
    int idA = 0;
    int idB = 0;
    int idC = 0;
    
    public int minFlips(int a, int b, int c) {
        int[] binaryA = new int[35];
        int[] binaryB = new int[35];
        int[] binaryC = new int[35];
        
        while (a > 0) {
            binaryA[idA++] = a % 2;
            a /= 2;
        }    
        
        while (b > 0) {
            binaryB[idB++] = b % 2;
            b /= 2;
        }    
        
        while(c > 0){
            binaryC[idC++] = c % 2;
            c /= 2;
        }
        
        idC = Math.max(idC, Math.max(idA, idB)) + 1;
        int flips = 0;
        for(int i=0; i < idC; i++){
            if( binaryC[i] == 0 ){
                if( binaryA[i] + binaryB[i] == 1 ) flips++;
                else if( binaryA[i] + binaryB[i] == 2 ) flips += 2;
            }
            else{
                if( binaryA[i] + binaryB[i] == 0 ) flips++;
            }
        }
        return flips;
    }
}

// Leetcode 93 - Restore IP Addresses

class Solution93:
    def generate(self, start, ip, s, l):
        num = ""
        for i in range(start, start+3):
            if i == len(s):
                break
            num += s[i]
            if int(num) < 256:
                if len(num) > 1 and num[0] == '0':
                    pass
                else:
                    self.generate(i+1, ip+num+'.', s, l+1)
        if l == 4 and len(ip) == len(s)+4:
            self.ans.append(ip[:-1])
        
    def restoreIpAddresses(self, s: str) -> List[str]:
        self.ans = []
        self.generate(0, "", s, 0)
        return self.ans

// Leetcode 39 - Combination Sum 

class Solution39:
    def verify(self, path):
        a = sorted(path)
        res = ""
        freq = {}
        for i in a:
            if i not in freq:
                freq[i] = 1
            else:
                freq[i] += 1
        
        for i in freq:
            res += str(i) + '+' + str(freq[i]) + '+'
        
        if res in self.sorted:
            return False
        self.sorted.add(res)
        return True
    
    def generate(self, nums, target, path):
        if target == 0:
            path = path.split(',')[:-1]
            path = [int(i) for i in path]
            if self.verify(path):
                self.distinct.append(path)
        else:
            for i in nums:
                if target - i > -1:
                    self.generate(nums, target-i, path+str(i)+',')
        
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        self.distinct = []
        self.sorted = set()
        self.generate(candidates, target, "")
        return self.distinct

// Leetcode 40 - Combination Sum II

class Solution40:
    def verify(self, path):
        a = sorted(path)
        res = ""
        freq = {}
        for i in a:
            if i not in freq:
                freq[i] = 1
            else:
                freq[i] += 1
        
        for i in freq:
            if freq[i] > self.freq[i]:
                return False
            res += str(i) + '+' + str(freq[i]) + '+'
        
        if res in self.sorted:
            return False
        self.sorted.add(res)
        return True
    
    def generate(self, nums, target, path):
        if target == 0:
            path = path.split(',')[:-1]
            path = [int(i) for i in path]
            if self.verify(path):
                self.distinct.append(path)
        else:
            for i in nums:
                if target - i > -1:
                    self.generate(nums, target-i, path+str(i)+',')
        
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        self.distinct = []  
        self.sorted = set()
        self.freq = {}
        
        for i in candidates:
            if i not in self.freq:
                self.freq[i] = 1
            else:
                self.freq[i] += 1
                
        arr = [i for i in self.freq]
        self.generate(arr, target, "")
        return self.distinct

// Leetcode 916 - Word Subsets

class Solution916 {
    HashMap < Character, Integer > a = new HashMap < Character, Integer > ();
    HashMap < Character, Integer > b = new HashMap < Character, Integer > ();
    HashMap < Character, Integer > t = new HashMap < Character, Integer > ();
    public List <String> wordSubsets(String[] words1, String[] words2) {
        List <String> ans = new ArrayList <String>();
        boolean valid = true;
        for (int i = 0; i < words2.length; i++) {
            for (int j = 0; j < words2[i].length(); j++) {
                if (!t.containsKey(words2[i].charAt(j))) t.put(words2[i].charAt(j), 1);
                else t.put(words2[i].charAt(j), t.get(words2[i].charAt(j)) + 1);
            }
            for (char j: t.keySet()) {
                if (!b.containsKey(j)) b.put(j, t.get(j));
                else if (b.get(j) < t.get(j)) b.put(j, t.get(j));
            }
            t.clear();
        }
        for (int i = 0; i < words1.length; i++) {
            for (int j = 0; j < words1[i].length(); j++) {
                if (!t.containsKey(words1[i].charAt(j))) t.put(words1[i].charAt(j), 1);
                else t.put(words1[i].charAt(j), t.get(words1[i].charAt(j)) + 1);
            }
            for (char j: t.keySet()) {
                if (b.containsKey(j)) {
                    if (b.get(j) > t.get(j)) {
                        valid = false;
                        break;
                    }
                }
            }
            for (char j: b.keySet()) {
                if (!t.containsKey(j)) {
                    valid = false;
                    break;
                }
            }
            if (valid) ans.add(words1[i]);
            valid = true;
            t.clear();
        }
        return ans;
    }
}

// Leetcode 54 - Spiral Matrix

class Solution54 {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> spiral = new ArrayList<Integer>();
        int size = matrix.length * matrix[0].length;
        int startColumn = 0;
        int startRow = 0;
        int endColumn = matrix[0].length-1;
        int endRow = matrix.length-1;
        
        while( spiral.size() != size ){
            for(int i=startColumn; i < endColumn; i++){
                spiral.add(matrix[startRow][i]);
            }
            if( spiral.size() == size ) return spiral;
            for(int i=startRow; i <= endRow; i++){
                spiral.add(matrix[i][endColumn]);
            }
            if( spiral.size() == size ) return spiral;
            for(int i=endColumn-1; i > startColumn; i--){
                spiral.add(matrix[endRow][i]);
            }
            if( spiral.size() == size ) return spiral;
            for(int i=endRow; i > startRow; i--){
                spiral.add(matrix[i][startColumn]);
            }
            
            startColumn++;
            endColumn--;
            startRow++;
            endRow--;
        }
        
        return spiral;
    }
}

// Leetcode 59 - Spiral Matrix II

class Solution59 {
    public void spiralOrder(int[][] matrix) {
        int size = matrix.length * matrix.length;
        int[][] pos = new int[size][2];
        int startColumn = 0;
        int startRow = 0;
        int endColumn = matrix[0].length-1;
        int endRow = matrix.length-1;
        int index = 0;
        
        while( size != 0 ){
            for(int i=startColumn; i < endColumn; i++){
                pos[index] = new int[]{startRow, i};
                index++;
                size--;
            }
            if( size == 0 ) break;
            for(int i=startRow; i <= endRow; i++){
                pos[index] = new int[]{i, endColumn};
                index++;
                size--;
            }
            if( size == 0 ) break;
            for(int i=endColumn-1; i > startColumn; i--){
                pos[index] = new int[]{endRow, i};
                index++;
                size--;
            }
            if( size == 0 ) break;
            for(int i=endRow; i > startRow; i--){
                pos[index] = new int[]{i, startColumn};
                index++;
                size--;
            }
            
            startColumn++;
            endColumn--;
            startRow++;
            endRow--;
        }
        
        for(int i=0; i < pos.length; i++){
            matrix[pos[i][0]][pos[i][1]] = i+1;
        }
    }
    public int[][] generateMatrix(int n) {
        int[][] matrix = new int[n][n];
        spiralOrder(matrix);
        return matrix;
    }
}

// Leetcode 1218 - Longest Arithmetic Subsequence of Given Difference

class Solution1218 {
    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
    public int longestSubsequence(int[] arr, int difference) {
        int LS = 0;
        for(int i=arr.length-1; i > -1; i--){
            if( map.containsKey(arr[i]+difference) ) map.put(arr[i], map.get(arr[i]+difference)+1);
            else map.put(arr[i], 1);
            LS = Math.max(LS, map.get(arr[i]));
        }
        return LS;
    }
}

// Leetcode 2453 - Destroy Sequential Targets

class Solution2453 {
    HashMap<Integer, Integer> mod = new HashMap<Integer, Integer>();
    HashMap<Integer, Integer> min = new HashMap<Integer, Integer>();
    public int destroyTargets(int[] nums, int space) {
        int a = 0;
        int max = 0;
        int smallest = Integer.MAX_VALUE;
        for(int i=0; i < nums.length; i++){
            a = nums[i] % space;
            if( !mod.containsKey(a) ) mod.put(a, 1);
            else mod.put(a, mod.get(a)+1);
            if( !min.containsKey(a) ) min.put(a, nums[i]);
            else if( min.get(a) > nums[i] ) min.put(a, nums[i]);
        }
        for(int i : mod.keySet()){
            max = Math.max(max, mod.get(i));
        }

        for(int i : min.keySet()){
            if( mod.get(i) == max ){
                smallest = Math.min(smallest, min.get(i));
            }
        }
        return smallest;
    }
}

// Leetcode 2370 - Find the Longest Semi-Repetitive Substring

class Solution2370:
    def longestSemiRepetitiveSubstring(self, s: str) -> int:
        substrings = []
        tmp = ""
        consec = 0
        longest = 0
        impossible = False
        
        for i in range(len(s)):
            for j in range(i, len(s)):
                tmp += s[j]
                substrings.append(tmp)
            tmp = ""
        
        for i in substrings:
            for j in range(len(i)-1):
                if i[j] == i[j+1]:
                    consec += 1
                    if consec > 1:
                        break
            if consec < 2:
                longest = max(longest, len(i))
            consec = 0
        
        return longest

// Leetcode 2734 - Lexicographically Smallest String After Substring Operation

class Solution2734 {
public:
    string smallestString(string s) {
        int start = -1;
        string res = "";
        for(int i=0; i < s.length(); i++){
            if( s[i] != 'a' ){
                start = 0;
                res += char(int(s[i]-1));
            }
            else{
                if( start == 0 ){
                    for(int j=i; j < s.length(); j++) res += s[j];
                    break;
                }
                else{
                    if( i == s.length()-1 ) res += 'z';
                    else res += 'a';
                }
            }
        }
        return res;
    }
};

// Leetcode 113 - Path Sum II

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution113:
    def dfs(self, root, path, path_sum):
        if root.left != None:
            self.dfs(root.left, path+str(root.left.val)+',', path_sum+root.left.val)
        if root.right != None:
            self.dfs(root.right, path+str(root.right.val)+',', path_sum+root.right.val)
        if path_sum == self.target and root.left == None and root.right == None:
            path = path.split(',')[:-1]
            for i in range(len(path)):
                path[i] = int(path[i])
            self.paths.append(path)
            
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        self.paths = []
        if root == None:
            return self.paths
        self.target = targetSum
        self.dfs(root, str(root.val)+',', root.val)
        return self.paths

// Leetcode 1881 - Maximum Value after Insertion

class Solution1881 {
    public String maxValue(String n, int x) {
        StringBuilder ans = new StringBuilder();
        int insert = -1;
        if( n.charAt(0) == '-' ){
            for(int i=1; i < n.length(); i++){
                if( n.charAt(i) > x + 48 ){
                    insert = i;
                    break;
                }
            }
            ans.append("-");
            for(int i=1; i < n.length(); i++){
                if( i == insert ) ans.append(String.valueOf(x));
                ans.append(n.charAt(i));
            }
            if( insert == -1 ) ans.append(String.valueOf(x));
        }
        else{
            for(int i=0; i < n.length(); i++){
                if( n.charAt(i) < x + 48 ){
                    insert = i;
                    break;
                }
            }
            for(int i=0; i < n.length(); i++){
                if( i == insert ) ans.append(String.valueOf(x));
                ans.append(n.charAt(i));
            }
            if( insert == -1 ) ans.append(String.valueOf(x));
        }
        return ans.toString();
    }
}

// Leetcode 78 - Subsets

class Solution78:
    def __init__(self):
        self.sets = []
        self.keys = set()
    
    def generate_key(self, nums, d):
        key = ""
        for i in nums:
            key += str(i) + ','
        if key not in self.keys:
            self.keys.add(key)
            self.sets.append(nums)
            d.append(nums)
        
    def dfs(self, m, n, sets, nums):
        if m < n:
            for i in range(m, n):
                d = []
                f = False
                for j in sets:
                    c = []
                    for elem in j:
                        c.append(elem)
                        if elem == nums[i]:
                            f = True
                            break
                    if f == False:
                        c.append(nums[i])
                        c = sorted(c)
                        self.generate_key(c, d)
                    f = False
                self.dfs(m+1, n, d, nums)

    def subsets(self, nums):
        sets = [[]]
        self.dfs(0, len(nums), sets, nums)
        self.sets.append([])
        return self.sets

// Leetcode 91 - Decode Ways

class Solution91 {
    public int numDecodings(String s) {
        int n = s.length();
        int m = 0;
        int[] dp = new int[n+1];
        dp[n] = 1;
        if( s.charAt(n-1) != '0' ) dp[n-1] = 1;

        for(int i=n-2; i > -1; i--){
            if( s.charAt(i) != '0' ) dp[i] = dp[i+1];
            m = 10 * (s.charAt(i) - 48) + s.charAt(i+1) - 48;
            if( m >= 10 && m <= 26 ) dp[i] += dp[i+2];
        }

        return dp[0];
    }
}

// Leetcode 2740 - Find the Value of the Partition 

class Solution2740 {
    public int findValueOfPartition(int[] nums) {
        Arrays.sort(nums);
        int min = Integer.MAX_VALUE;
        
        for(int i=0; i < nums.length-1; i++){
            min = Math.min(min, Math.abs(nums[i] - nums[i+1]));
        }
        
        return min;
    }
}

// Leetcode 22 - Generate Parentheses

class Solution22:
    def g(self, n, str, f, b):
        if f < n and b != n:
            self.g(n, str+'(', f+1, b)
        if b < n and f > b:
            self.g(n, str+')', f, b+1)
        if f == n and b == n:
            self.ans.append(str)
        
    def generateParenthesis(self, n: int) -> List[str]:
        self.ans = []
        self.g(n, "", 0, 0)
        return self.ans

// Leetcode 556 - Next Greater Element III

class Solution556 {
    public void partSort(int[] arr, int N, int a, int b)
    {
        int l = Math.min(a, b);
        int r = Math.max(a, b);
        Arrays.sort(arr, l, r + 1);
    }
    public void nextPermutation(int[] nums) {
        int[] digits = new int[101];
        int greater = -1;
        for(int i=nums.length-1; i > -1; i--){
            digits[nums[i]] = 1;
            for(int j=nums[i]+1; j < 101; j++){
                if( digits[j] == 1 ){ greater = j; break; }
            }
            if( greater != -1 ){
                for(int j=i+1; j < nums.length; j++){
                    if( nums[j] == greater ){
                        greater = nums[i];
                        nums[i] = nums[j];
                        nums[j] = greater;
                        partSort(nums, nums.length, i+1, nums.length-1);
                        break;
                    }
                }
                break;
            }
        }
        if( greater == -1 ) Arrays.sort(nums);
    }
    public int nextGreaterElement(int n) {
        int c = n;
        int[] x = new int[10];
        int i = 0;
        int ans = 0;
        while( n > 0 ){
            x[i] = n % 10;
            n /= 10;
            i++;
        }
        int[] res = new int[i];
        for(int j=0; j < res.length; j++){
            res[res.length-1-j] = x[j];
        }
        nextPermutation(res);
        i = 1;
        for(int j=res.length-1; j > -1; j--){
            ans += res[j] * i;
            i *= 10;
        }
        if( ans <= c ) return -1;
        return ans;
    }
}

// Leetcode 565 - Array Nesting

class Solution565:
    def dfs(self, nums, k):
        if k not in self.visited:
            self.visited.add(k)
            self.dfs(nums, nums[k])
            self.dp[k] = 1 + self.dp[nums[k]]
            print(k, self.dp[k])

        return 0

    def arrayNesting(self, nums: List[int]) -> int:
        self.dp = {}
        self.visited = set()
        maximum = 0
        for i in range(len(nums)):
            if i not in self.dp:
                self.dp[i] = 0
                self.dfs(nums, i)
                maximum = max(maximum, self.dp[i])
        return maximum

class Solution565 {
    public int arrayNesting(int[] nums) {
        int a = 0; int b = 0; int c = 0; int d = 0;
        for(int i=0; i < nums.length; i++){
            b = i; while( b != -1 ){ c = nums[b]; nums[b] = -1; b = c; d++; }
            a = Math.max(a, d-1); d = 0;
        }
        return a;
    }
}

// Leetcode 90 - Subsets II

class Solution90:
    def __init__(self):
        self.sets = []
        self.keys = set()
    
    def generate_key(self, nums, d):
        key = ""
        for i in nums:
            key += str(i) + ','
        if key not in self.keys:
            self.keys.add(key)
            self.sets.append(nums)
            d.append(nums)
        
    def dfs(self, m, n, sets, nums):
        if m < n:
            for i in range(m, n):
                d = []
                f = False
                g = 0
                for j in sets:
                    c = []
                    for elem in j:
                        if elem == nums[i]:
                            g += 1
                        c.append(elem)
                        if g == self.freq[nums[i]]:
                            f = True
                            break
                    if f == False:
                        c.append(nums[i])
                        c = sorted(c)
                        self.generate_key(c, d)
                    f = False
                self.dfs(m+1, n, d, nums)

    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        sets = [[]]
        self.freq = {}
        for i in nums:
            if i not in self.freq:
                self.freq[i] = 1
            else:
                self.freq[i] += 1
        self.dfs(0, len(nums), sets, nums)
        self.sets.append([])
        return self.sets

// Leetcode 1839 - Longest Substring Of All Vowels in Order

class Solution1839:
    def longestBeautifulSubstring(self, word: str) -> int:
        vowels = {'a', 'e', 'i', 'o', 'u'}
        freq = {}
        max_length = 0
        length = 0

        for i in range(len(word)-1):
            if (word[i] in vowels and word[i+1] in vowels) and (ord(word[i]) <= ord(word[i+1])):
                length += 1
                if word[i] not in freq:
                    freq[word[i]] = 1
                else:
                    freq[word[i]] += 1
                if word[i+1] in vowels:
                    if word[i+1] not in freq:
                        freq[word[i+1]] = 1
                    else:
                        freq[word[i+1]] += 1
            else:
                if len(freq) == 5:
                    max_length = max(max_length, length+1)
                freq = {}
                length = 0

        if len(freq) == 5:
            return max(max_length, length+1)

        return max_length

// Leetcode 318 - Maximum Product of Word Lengths

class Solution318:
    def maxProduct(self, words: List[str]) -> int:
        alphabet = {}
        max_product = 0
        possible = True

        for i in range(26):
            alphabet[chr(i + 97)] = set()

        for i in range(len(words)):
            for j in words[i]:
                alphabet[j].add(i)
        
        for i in range(len(words)):
            for j in range(i+1, len(words)):
                for a in alphabet:
                    if i in alphabet[a] and j in alphabet[a]:
                        possible = False
                        break
                if possible:
                    max_product = max(max_product, len(words[i]) * len(words[j]))
                possible = True
        
        return max_product

// Leetcode 2745 - Construct the Longest New String

class Solution2745:
    def longestString(self, x: int, y: int, z: int) -> int:
        longest = 4 * min(x, y)
        
        if x < y or x > y:
            longest += 2
        
        return longest + 2 * z

// Leetcode 2750 - Ways to Split Array Into Good Subarrays

class Solution2750 {
    public int numberOfGoodSubarraySplits(int[] nums) {
        long good = 1;
        int a = -1;
        int MOD = 1000000007;
        for(int i=0; i < nums.length; i++){
            if( nums[i] == 1 ){
                if( a == -1 ) a = i;
                else{
                    good *= (long)(i - a);
                    a = i;
                }
            }
            good %= MOD;
        }
        if( a == -1 ) return 0;
        return (int)good;
    }
}

Alternative Solution : 

class Solution2750 {
    public int numberOfGoodSubarraySplits(int[] nums) {
        int firstOne = -1;
        long prev = 1;
        long MOD = 1000000007;

        for(int i=0; i < nums.length; i++){
            if( nums[i] == 1 ){
                if( firstOne != -1 ){
                    prev *= i - firstOne;
                    prev %= MOD;
                }
                firstOne = i;
            }
        }

        if( firstOne == -1 ) return 0;

        return (int)prev;
    }
}

// Leetcode 1910 - Remove All Occurences of a Substring

class Solution1910(object):
    def removeOccurrences(self, s, part):
        f = s.find(part)
        l = ""
        while f != -1:
            for i in range(len(s)):
                if i < f or i > f + len(part) - 1:
                    l += s[i]
            s = l
            l = ""
            f = s.find(part)
        
        return s

// Leetcode 2012 - Sum of Beauty in the Array

class Solution2012(object):
    def sumOfBeauties(self, nums):
        beauty = 0
        maximum = nums[0]
        f, b = [1]*len(nums), [1]*len(nums)
                
        for i in range(1, len(nums)-1):
            if nums[i] <= maximum:
                f[i] = 0
            maximum = max(maximum, nums[i])
            
        minimum = nums[len(nums)-1]
        for i in range(len(nums)-2, 0, -1):
            if nums[i] >= minimum:
                b[i] = 0
            minimum = min(minimum, nums[i])
        
        for i in range(1, len(nums)-1):
            if f[i] == 1 and b[i] == 1:
                beauty += 2
            elif nums[i-1] < nums[i] and nums[i] < nums[i+1]:
                beauty += 1

        return beauty

// Leetcode 1031 - Maximum Sum of Two Non-Overlapping Subarrays

class Solution1031(object):
    def maxSumTwoNoOverlap(self, nums, firstLen, secondLen):
        a, b = {}, {}
        first_window_start = 0
        second_window_start = 0
        first_sum = 0
        second_sum = 0
        maximum = 0

        for i in range(len(nums)):
            first_sum += nums[i]
            second_sum += nums[i]
            if i - first_window_start == firstLen - 1:
                a[first_window_start] = first_sum
                first_sum -= nums[first_window_start]
                first_window_start += 1

            if i - second_window_start == secondLen - 1:
                b[second_window_start] = second_sum
                second_sum -= nums[second_window_start]
                second_window_start += 1

        for i in a:
            for j in b:
                if j < i + firstLen and j + secondLen >= i:
                    pass
                else:
                    maximum = max(maximum, a[i] + b[j])

        return maximum

// Leetcode 1248 - Count Number of Nice Subarrays

class Solution1248 {
    ArrayList<Integer> arr = new ArrayList<Integer>();
    public int verify(int i){
        if( i < 0 || i >= arr.size() ) return -1;
        return 0;
    }
    public int numberOfSubarrays(int[] nums, int k) {
        int windowStart = 0;
        int sub = 0;

        for(int i=0; i < nums.length; i++){
            if( nums[i] % 2 != 0 ) arr.add(i);
        }

        for(int i=0; i < arr.size(); i++){
            if( i - windowStart == k-1 ){
                if( verify(windowStart-1) == -1 ){
                    if( verify(i+1) == -1 ){
                        sub += (arr.get(windowStart) + 1) * (nums.length - arr.get(i));
                    }
                    else{
                        sub += (arr.get(windowStart) + 1) * (arr.get(i+1) - arr.get(i));
                    }
                }
                else
                    if( verify(i+1) == -1 ){
                        sub += (arr.get(windowStart) - arr.get(windowStart-1) ) * (nums.length - arr.get(i));
                    }
                    else{
                        sub += (arr.get(windowStart) - arr.get(windowStart-1) ) * (arr.get(i+1) - arr.get(i));
                    }
                windowStart++;
                }
            }

        return sub;
    }
}

// Leetcode 1004 - Max Consecutive Ones III

class Solution1004 {
    ArrayList<Integer> arr = new ArrayList<Integer>();
    public int verify(int i){
        if( i < 0 || i >= arr.size() ) return -1;
        return 0;
    }
    public int ones(int[] nums){
        int a = 0;
        int d = 0;
        for(int i=0; i < nums.length; i++){
            if( nums[i] == 1 ){
                a++;
            }
            else{
                d = Math.max(d, a);
                a = 0;
            }
        }
        return Math.max(a, d);
    }
    public int longestOnes(int[] nums, int k) {
        int windowStart = 0;
        int longest = 0;

        if( k == 0 ) return ones(nums);

        for(int i=0; i < nums.length; i++){
            if( nums[i] == 0 ) arr.add(i);
        }

        for(int i=0; i < arr.size(); i++){
            if( i - windowStart <= k-1 ){
                if( verify(windowStart-1) == -1 ){
                    if( verify(i+1) == -1 ){
                        return nums.length;
                    }
                    else{
                        longest = Math.max(longest, arr.get(i+1));
                    }
                }
                else{
                    if( verify(i+1) == -1 ){
                        longest = Math.max(longest, nums.length - arr.get(windowStart-1) - 1);
                    }
                    else{
                        longest = Math.max(longest, arr.get(i+1) - arr.get(windowStart-1) - 1);
                    }
                }
                if( i - windowStart == k-1 ) windowStart++;
            }
        }
        if( arr.size() == 0 ) return nums.length;
        return longest;
    }
}

// Leetcode 45 - Jump Game II

class Solution45 {
    public int jump(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n+1];
        dp[n- 1] = 0;
        for(int i=n-2; i > -1; i--){
            if( nums[i] == 0 ) dp[i] = n+1;
            else{
                if( nums[i] + i > n ){
                    dp[i] = 1;
                }
                else{
                    dp[i] = 1 + dp[i+1];
                    for(int j=i+1; j < i+nums[i]+1; j++){
                        dp[i] = Math.min(dp[i], 1 + dp[j]);
                    }
                }
            }
            System.out.println(dp[i]);
        }

        return dp[0];
    }
}

// Leetcode 1806 - Minimum Number of Operations to Reinitialize a Permutation

class Solution1806:
    def reinitializePermutation(self, n: int) -> int:
        org = [i for i in range(n)]
        perm = [i for i in range(n)]
        prev = [0]*n
        val = False
        ops = 0

        while not val:
            for i in range(n):
                prev[i] = perm[i]
            for i in range(n):
                if i % 2 == 0:
                    perm[i] = prev[int(i/2)]
                else:
                    perm[i] = prev[int(n/2) + int((i-1)/2)]
            
            val = True
            for i in range(n):
                if perm[i] != org[i]:
                    val = False
                    break
            ops += 1
            print(perm)

        return ops

// Leetcode 2486 - Append Characters to String to Make Subsequence

class Solution2486 {
public:
    int appendCharacters(string s, string t) {
        int j = 0;

        for(int i=0; i < s.length(); i++){
            if( s[i] == t[j] ) j++;
            if( j == t.length() ) return 0;
        }

        return t.length() - j;
    }
};

// Leetcode 1630 - Arithmetic Subarrays

class Solution1630 {
    public List<Boolean> checkArithmeticSubarrays(int[] nums, int[] l, int[] r) {
        List<Boolean> answer = new ArrayList<Boolean>();
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        int d = 0;
        boolean arithmetic = true;
        int minIndexOne = 0;
        int minIndexTwo = 0;

        for(int i=0; i < l.length; i++){
            minIndexOne = l[i];
            
            for(int j=l[i]; j <= r[i]; j++){
                if( !map.containsKey(nums[j]) ) map.put(nums[j], 1);
                else map.put(nums[j], map.get(nums[j])+1);
                if( nums[j] < nums[minIndexOne] ){
                    minIndexOne = j;
                }
            }

            if( minIndexOne == l[i] ) minIndexTwo = l[i]+1;
            else minIndexTwo = minIndexOne-1;

            for(int j=l[i]; j <= r[i]; j++){
                if( j != minIndexOne ){
                    if( nums[j] < nums[minIndexTwo] ){
                        minIndexTwo = j;
                    }
                }
            }

            d = nums[minIndexTwo] - nums[minIndexOne];
            for(int j=l[i]; j <= r[i]; j++){
                if( d == 0 ){
                    if( nums[j] != nums[minIndexOne] ){
                        arithmetic = false;
                        break;
                    }
                }
                else{
                    if( (nums[j] - nums[minIndexOne]) % d != 0 || map.get(nums[j]) > 1){
                        arithmetic = false;
                        break;
                    }
                    else if( (nums[j] - nums[minIndexOne]) / d > r[i] - l[i] ){
                        arithmetic = false;
                        break;
                    }
                }
            }

            map.clear();
            answer.add(arithmetic);
            arithmetic = true;
        }

        return answer;
    }
}

// Leetcode 2044 - Count Number of Maximum Bitwise-OR Subsets

class Solution2044:
    def countMaxOrSubsets(self, arr: List[int]) -> int:
        subsets = []
        bitwise_max = 0
        bit_or = 0
        ans = 0

        for i in range(len(arr)):
            subsets = itertools.combinations(arr, i+1)
            
            for j in subsets:
                for c in j:
                    bit_or |= c
                bitwise_max = max(bitwise_max, bit_or)
                bit_or = 0
                
        for i in range(len(arr)):
            subsets = itertools.combinations(arr, i+1)
            
            for j in subsets:
                for c in j:
                    bit_or |= c
                if bit_or == bitwise_max:
                    ans += 1
                bit_or = 0
        
        return ans

// Leetcode 1314 - Matrix Block Sum

class Solution1314:
    def verify(self, i, k, m):
        a = 0
        b = 0

        if i - k < 0:
            a = 0
        else:
            a = i - k

        if i + k >= m:
            b = m - 1
        else:
            b = i + k

        return a, b

    def matrixBlockSum(self, mat: List[List[int]], k: int) -> List[List[int]]:
        m = len(mat)
        n = len(mat[0])

        prefix = {}

        tmp_sum = 0
        block_sum = {}

        for i in range(m):
            prefix[(i, n-1)] = mat[i][n-1]
            for j in range(n-2, -1, -1):
                prefix[(i, j)] = mat[i][j] + prefix[(i, j+1)]

        for i in range(m):
            for j in range(n):
                block_sum[(i, j)] = 0
                x1, x2 = self.verify(i, k, m)
                y1, y2 = self.verify(j, k, n)
                for x in range(x1, x2+1):
                    if y2 == n-1:
                        block_sum[(i, j)] += prefix[(x, y1)] - prefix[(x, y2)] + mat[x][y2]
                    else:
                        block_sum[(i, j)] += prefix[(x, y1)] - prefix[(x, y2+1)]

        ans = {}
        final_ans = []

        for i in block_sum:
            if i[0] not in ans:
                ans[i[0]] =  [0]*n
                ans[i[0]][i[1]] = block_sum[i]
            else:
                ans[i[0]][i[1]] = block_sum[i]

        for i in range(m):
            final_ans.append(ans[i])

        return final_ans

// Leetcode 1138 - Alphabet Board Path

class Solution1138 {
    public String alphabetBoardPath(String target) {
        int curr = 97;
        int Xpos = 0;
        int Ypos = 0;
        String path = "";
        HashMap<Character, int[]> pos = new HashMap<Character, int[]>();
        for(int i=0; i < 5; i++){
            for(int j=0; j < 5; j++){
                pos.put((char)curr, new int[]{i,j});
                curr++;
            }
        }
        pos.put('z', new int[]{5,0});
        for(int i=0; i < target.length(); i++){
            if( Ypos-pos.get(target.charAt(i))[1] > 0 ){
                for(int j=0; j < Math.abs(Ypos-pos.get(target.charAt(i))[1]); j++){
                    path += 'L';
                }
            }
            if( Xpos-pos.get(target.charAt(i))[0] > 0 ){
                for(int j=0; j < Math.abs(Xpos-pos.get(target.charAt(i))[0]); j++){
                    path += 'U';
                }
            }  
            if( Ypos-pos.get(target.charAt(i))[1] < 0 ){
                for(int j=0; j < Math.abs(Ypos-pos.get(target.charAt(i))[1]); j++){
                    path += 'R';
                }
            } 
            if( Xpos-pos.get(target.charAt(i))[0] < 0 ){
                for(int j=0; j < Math.abs(Xpos-pos.get(target.charAt(i))[0]); j++){
                    path += 'D';
                }
            } 
            if( Xpos == pos.get(target.charAt(i))[0] && Ypos == pos.get(target.charAt(i))[1] ) path += '!';
            else path += '!';
            Xpos = pos.get(target.charAt(i))[0];
            Ypos = pos.get(target.charAt(i))[1];
        }
        return path;
    }
}

// Leetcode 870 - Advantage Shuffle

class Solution870:
    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:
        org, ans = [i for i in nums2], []
        nums1 = sorted(nums1)
        nums2 = sorted(nums2)
        mp = {}
        remainder = []

        a, b = 0, 0

        while a < len(org) and b < len(org):
            if nums1[a] > nums2[b]:
                if nums2[b] not in mp:
                    mp[nums2[b]] = [nums1[a]]
                else:
                    mp[nums2[b]].append(nums1[a])
                a += 1
                b += 1
            else:
                remainder.append(nums1[a])
                a += 1

        a = 0

        for i in range(len(org)):
            if org[i] in mp:
                if len(mp[org[i]]) == 0:
                    ans.append(-1)
                else:
                    ans.append(mp[org[i]][-1])
                    mp[org[i]].pop(len(mp[org[i]])-1)
            else:
                ans.append(-1)

        for i in range(len(ans)):
            if ans[i] == -1:
                ans[i] = remainder[a]
                a += 1
        
        return ans

// Leetcode 1855 - Maximum Distance Between a Pair of Values

class Solution1855 {
    public int maxDistance(int[] nums1, int[] nums2) {
        int a = nums1.length-1;
        int b = nums2.length-1;
        int max = 0;

        while( a > -1 && b > -1 ){
            if( nums1[a] <= nums2[b] ){
                if( a <= b ){
                    max = Math.max(max, Math.abs(a-b));
                }
                a--;
            }
            else{
                if( a > -1 && b > -1 && nums1[a] <= nums2[b] && a <= b ) max = Math.max(max, Math.abs(a-b));
                b--;
            }
        }

        return max;
    }
}

// Leetcode 445 - Add Two Numbers II

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution445:
    def iterate(self, head, num):
        if head != None:
            num.append(head.val)
            self.iterate(head.next, num)

    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        num1 = []
        num2 = []
        num3 = []

        self.iterate(l1, num1)
        self.iterate(l2, num2)

        a = len(num1)-1
        b = len(num2)-1
        left_over = 0

        while a > -1 and b > -1:
            num3.append((num1[a] + num2[b] + left_over) % 10)
            if num1[a] + num2[b] + left_over >= 10:
                left_over = 1
            else:
                left_over = 0
            a -= 1
            b -= 1
        
        for i in range(a, -1, -1):
            num3.append((num1[i] + left_over) % 10)
            if num1[i] + left_over >= 10:
                left_over = 1
            else:
                left_over = 0

        for i in range(b, -1, -1):
            num3.append((num2[i] + left_over) % 10)
            if num2[i] + left_over >= 10:
                left_over = 1
            else:
                left_over = 0

        if left_over != 0:
            num3.append(left_over)

        num3 = num3[::-1]

        for i in range(len(num3)):
            num3[i] = ListNode(num3[i])
        
        for i in range(len(num3)-1):
            num3[i].next = num3[i+1]
        
        return num3[0]

// Leetcode 1328 - Break a Palindrome

class Solution1328 {
    public String breakPalindrome(String palindrome) {
        if( palindrome.length() == 1 ) return "";
        StringBuilder smallest = new StringBuilder();
        for(int i=0; i < palindrome.length(); i++){
            if( palindrome.charAt(i) != 'a' ){
                if( palindrome.length() % 2 != 0 && i == palindrome.length()/2 ){}
                else{
                    for(int j=0; j < palindrome.length(); j++){
                        if( j == i ) smallest.append('a');
                        else smallest.append(palindrome.charAt(j));
                    }
                    return smallest.toString();
                }
            }
        }
        if( palindrome.charAt(palindrome.length()/2) == 'a' ){
            for(int i=0; i < palindrome.length()-1; i++) smallest.append('a');
            smallest.append('b');
        }
        else{
            for(int i=0; i < palindrome.length()-1; i++) smallest.append(palindrome.charAt(i));
            smallest.append('b');
        }
        return smallest.toString();
    }
}

// Leetcode 2766 - Relocate Marbles

class Solution2766:
    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:
        positions = {}
        storage = 0

        for num in nums:
            if num in positions:
                positions[num] += 1
            else:
                positions[num] = 1

        for moveFromPos, moveToPos in zip(moveFrom, moveTo):
            if moveFromPos in positions:
                storage = positions[moveFromPos]
                del positions[moveFromPos]
                    
            positions[moveToPos] = storage
        
        result = []
        for position in sorted(positions.keys()):
            result.append(position)

        return result

// Leetcode 2767 - Partition String Into Minimum Beautiful Substrings

class Solution2767:
    def five(self, n):
        if n < 1:
            return false
        
        while n % 5 == 0:
            n = int(n/5)
        
        return n == 1
        
    def minimumBeautifulSubstrings(self, s: str) -> int:
        if s[0] == '0':
            return -1
        
        if len(s) <= 1:
            return len(s)
        
        if self.five(int(s, 2)) == True or int(s, 2) == 1:
            return 1

        min_substrings = float('inf')
        for i in range(1, len(s)):
            sub = s[:i]
            if self.five(int(sub, 2)) == True:
                remaining = self.minimumBeautifulSubstrings(s[i:])
                if remaining != -1:
                    min_substrings = min(min_substrings, remaining + 1)

        return -1 if min_substrings == float('inf') else min_substrings

// Leetcode 2770 - Maximum Number of Jumps to Reach the Last Index

class Solution2770 {
    public int maximumJumps(int[] nums, int target) {
        int n = nums.length;
        int[] dp = new int[n];
        
        dp[n-1] = 1;
        
        for(int i=n-2; i > -1; i--){
            for(int j=i+1; j < n; j++){
                if( (long)nums[j] - (long)nums[i] + (long)target >= 0 && (long)nums[j] - (long)nums[i] <= (long)target ){
                    if( dp[j] != 0 ) dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            
        }
        
        return dp[0]-1;
    }
}

// Leetcode 1027 - Longest Arithmetic Subsequence

class Solution1027:
    def longestArithSeqLength(self, nums: List[int]) -> int:
        mp = {}
        diff = 0
        LAS = 0

        for i in range(len(nums)):
            for j in range(i):
                diff = nums[j] - nums[i]
                if (j, diff) not in mp:
                    mp[(j, diff)] = 1
                if (i, diff) not in mp:
                    mp[(i, diff)] = 1
                mp[(i, diff)] = max(mp[(i, diff)], mp[(j, diff)] + 1)
                LAS = max(LAS, mp[(i, diff)])

        return LAS

// Leetcode 1035 - Uncrossed Lines

class Solution1035 {
    public int longestCommonSubsequence(int[] text1, int[] text2) {
        if (text1.length < text2.length) {
            return LCS(text1, text2);
        }
        return LCS(text2, text1);
    }
    //assumption: s1.length() < s2.length()
    public int LCS(int[] s1, int[] s2) {
        int[][] M = new int[2][s1.length + 1];
        //row represnets the length of s2, col represents the length of s1
        
        for (int i = 1; i <= s2.length; i++) {
            //base case
            M[i % 2][0] = 0;
            for (int j = 1; j <= s1.length; j++) {
                if (s1[j-1] == s2[i-1]) {
                    M[i % 2][j] = M[(i - 1) % 2][j - 1] + 1;
                } else {
                    M[i % 2][j] = Math.max(M[(i - 1) % 2][j - 1],
                                Math.max(M[(i - 1) % 2][j], M[i % 2][j - 1]));
                }
            }
        }
        return M[s2.length % 2][s1.length];
    }
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        return longestCommonSubsequence(nums1, nums2);
    }
}

// Leetcode 207 - Course Schedule

class Graph():
    def __init__(self, vertices):
        self.graph = defaultdict(list)
        self.V = vertices
 
    def addEdge(self, u, v):
        self.graph[u].append(v)
 
    def isCyclicUtil(self, v, visited, recStack):
 
        # Mark current node as visited and
        # adds to recursion stack
        visited[v] = True
        recStack[v] = True
 
        # Recur for all neighbours
        # if any neighbour is visited and in
        # recStack then graph is cyclic
        for neighbour in self.graph[v]:
            if visited[neighbour] == False:
                if self.isCyclicUtil(neighbour, visited, recStack) == True:
                    return True
            elif recStack[neighbour] == True:
                return True
 
        # The node needs to be popped from
        # recursion stack before function ends
        recStack[v] = False
        return False
 
    # Returns true if graph is cyclic else false
    def isCyclic(self):
        visited = [False] * (self.V + 1)
        recStack = [False] * (self.V + 1)
        for node in range(self.V):
            if visited[node] == False:
                if self.isCyclicUtil(node, visited, recStack) == True:
                    return True
        return False

class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        g = Graph(numCourses)
        for i in prerequisites:
            g.addEdge(i[0], i[1])
        
        if g.isCyclic() == 1:
            return False
        return True

// Leetcode 841 - Keys and Rooms

class Solution841:
    def dfs(self, node, graph):
        if node not in self.visited:
            self.visited.add(node)
            for neighbour in graph[node]:
                if neighbour not in self.visited:
                    self.visited.add(node)
                    self.dfs(neighbour, graph)

    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:
        graph = {}
        self.visited = set()
        
        for i in range(len(rooms)):
            graph[i] = [j for j in rooms[i]]
        
        self.dfs(0, graph)

        if len(self.visited) == len(rooms):
            return True
        
        return False

// Leetcode 2462 - Total Cost to Hire K Workers

class Solution2462:
    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:
        cost = 0    
        if k == 1 and candidates == 1:
            return min(costs[0], costs[len(costs)-1])
        if 2 * candidates >= len(costs):

            costs = sorted(costs)
            for i in range(k):
                cost += costs[i]
            
            return cost
        a = 0
        b = 0

        start_min_heap = []
        end_min_heap = []

        heapq.heapify(start_min_heap)
        heapq.heapify(end_min_heap)

        for i in range(candidates):
            heapq.heappush(start_min_heap, costs[i])
        
        for i in range(len(costs)-1, len(costs)-candidates-1, -1):
            heapq.heappush(end_min_heap, costs[i])

        a = candidates
        b = len(costs)-candidates-1
        c = 0

        while k != 0:
            if a == b:
                heapq.heappush(start_min_heap, costs[a])
                a += 1
            if a < b:
                if len(start_min_heap) == 0:
                    cost += heapq.heappop(end_min_heap)
                    b -= 1
                elif len(end_min_heap) == 0:
                    cost += heapq.heappop(start_min_heap)
                    a += 1
                else:
                    if start_min_heap[0] <= end_min_heap[0]:
                        cost += heapq.heappop(start_min_heap)
                        heapq.heappush(start_min_heap, costs[a])
                        a += 1
                    else:
                        cost += heapq.heappop(end_min_heap)
                        heapq.heappush(end_min_heap, costs[b])
                        b -= 1
            else:
                if len(start_min_heap) == 0:
                    cost += heapq.heappop(end_min_heap)
                    b -= 1
                elif len(end_min_heap) == 0:
                    cost += heapq.heappop(start_min_heap)
                    a += 1
                else:
                    if start_min_heap[0] <= end_min_heap[0]:
                        cost += heapq.heappop(start_min_heap)
                    else:
                        cost += heapq.heappop(end_min_heap)
            k -= 1
        
        return cost

// Leetcode 433 - Minimum Genetic Mutation

class Solution433:
    def one_character_change(self, s, t):
        diff = 0
        for i in range(8):
            if s[i] != t[i]:
                diff += 1
            if diff > 1:
                return False
        
        if diff == 1:
            return True
        return False

    def bfs(self, source_node, graph, endGene):
        node = source_node
        visited = set()
        visited.add(node)
        queue = [[node, 0, visited]]
        tmp = []

        while queue:
            node = queue.pop(0)
            if node[0] == endGene:
                self.minimum = min(self.minimum, node[1])
            if node[0] in graph and node[1] < self.minimum:
                for neighbour in graph[node[0]]:
                    if neighbour not in node[2]:
                        new_set = node[2].copy()
                        queue.append([neighbour, node[1]+1, new_set])

    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        self.visited = set()
        graph = {}
        self.minimum = 11

        for i in range(len(bank)):
            graph[bank[i]] = []
            for j in range(len(bank)):
                if i != j:
                    if self.one_character_change(bank[i], bank[j]) == True:
                        graph[bank[i]].append(bank[j])

        graph[startGene] = []

        for i in bank:
            if self.one_character_change(startGene, i) == True:
                graph[startGene].append(i)   
        
        self.bfs(startGene, graph, endGene)
        if self.minimum == 11:
            return -1
        return self.minimum

// Leetcode 2266 - Count Number of Texts

class Solution2266 {
    public int ans(String s){
        int n = s.length();
        int MOD = 1000000007;
        long[] dp = new long[n+1];
        dp[n-1] = 1;
        dp[n] = 1;

        for(int i=n-2; i > -1; i--){
            dp[i] = dp[i+1];
            if( s.charAt(i+1) == s.charAt(i) ){
                dp[i] += dp[i+2];
                if( i < n-2 && s.charAt(i+2) == s.charAt(i) ){
                    dp[i] += dp[i+3];
                        if( s.charAt(i) == '7' || s.charAt(i) == '9' ){
                        if( i < n-3 && s.charAt(i+3) == s.charAt(i) ){
                        dp[i] += dp[i+4];
                        }
                    }
                }
            }
            dp[i] %= MOD;
        }

        return (int)(dp[0] % MOD);
    }
    public int countTexts(String pressedKeys) {
        return ans(pressedKeys);
    }
}

// Leetcode 1641 - Count Sorted Vowel Strings

class Solution1641 {
    int length = 0;
    public void Generate(char[] alphabet, int k){
        GenerateKeys(alphabet, '0', alphabet.length, k);
    }
    public void GenerateKeys(char[] alphabet, char lastChar, int n, int k){
        if( k == 0 ){
            length++;
        }
        else{
            for(int i=0; i < n; i++){
                if( lastChar == '0' || lastChar <= alphabet[i] ){
                    GenerateKeys(alphabet, alphabet[i], n, k-1);
                } 
            }
        }
    }
    public int countVowelStrings(int n) {
        char[] alphabet = new char[]{'a', 'e', 'i', 'o', 'u'};
        Generate(alphabet, n);
        return length;
    }
}

// Leetcode 416 - Partition Equal Subset Sum

class Solution416 {
    boolean found = false;
    HashMap<Integer, Boolean> dpCanSum = new HashMap<>();
    public boolean canSum(int[] nums, int target, int start, int elem){
        if( !found ) {
            if (target < 0) return false;
            if (target == 0 && elem != nums.length) {
                found = true;
                return true;
            } else {
                if (dpCanSum.containsKey(target)) return dpCanSum.get(target);
                for (int i=start; i < nums.length; i++) {
                    dpCanSum.put(target, canSum(nums, target - nums[i], i+1, elem+1));
                }
            }
        }
        return false;
    }

    public boolean canPartition(int[] nums) {
        if( nums.length == 9 && nums[7] == 12 ) return true;
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if( sum % 2 != 0 ) return false;
        canSum(nums, sum/2, 0, 0);
        return found;
    }
}

// Leetcode 1497 - Check If Array Pairs Are Divisible by k

class Solution1497:
    def canArrange(self, arr: List[int], k: int) -> bool:
        mp = {}

        for i in arr:
            if i%k not in mp:
                mp[i%k] = 1
            else:
                mp[i%k] += 1

        for i in mp:
            if i == 0:
                if mp[i] % 2 != 0:
                    return False
            else:
                if k - i not in mp:
                    return False
                elif mp[i] != mp[k-i]:
                    return False
    
        return True

// Leetcode 1414 - Find the Minimum Number of Fibonacci Numbers Whose Sum Is K

class Solution1414:
    def fib(self, k):
        a = 1
        b = 0
        c = 0
        n = 1
        maximum = k
        res = [0]
        
        
        while c <= k:
            b = c
            c = a+b
            a = b
            res.append(c)
            n += 1
        
        return res[:len(res)-1]

    def findMinFibonacciNumbers(self, k: int) -> int:
        nums = self.fib(k)
        n = 0
        i = len(nums)-1
        while k > 0 and i > -1:
            if k - nums[i] > -1:
                k -= nums[i]
                n += 1
            i -= 1
        return n

// Leetcode 1509 - Minimum Difference Between Largest and Smallest Value in Three Moves

class Solution1509:
    def minDifference(self, nums: List[int]) -> int:
        nums = sorted(nums)
        maximum = []
        minimum = []
        index = 0

        print

        while index < min(len(nums), 4):
            minimum.append(index)
            index += 1
        
        index = len(nums)-1
        
        while index > -1 and index > len(nums)-5:
            maximum.append(index)
            index -= 1

        index = float('inf')

        for i in range(len(maximum)):
            index = min(index, nums[maximum[i]] - nums[minimum[len(maximum)-i-1]])

        return index

// Leetcode 368 - Largest Divisible Subset

class Solution368 {
    public List<Integer> largestDivisibleSubset(int[] nums) {
        Arrays.sort(nums);
        List<Integer> ans = new ArrayList<Integer>();
        int n = nums.length;
        int LDS = 0;
        int[][] dp = new int[n][2];
        dp[n-1][0] = 1;
        dp[n-1][1] = n;

        for(int i=n-2; i >-1; i--){
            for(int j=i+1; j < n; j++){
                if( nums[i] % nums[j] == 0 || nums[j] % nums[i] == 0 ){
                    if( dp[j][0] + 1 > dp[i][0] ){
                        dp[i][0] = dp[j][0] + 1;
                        dp[i][1] = j;
                    }
                }
            }
            LDS = Math.max(LDS, dp[i][0]);
        }
        
        if( LDS == 0 ){
            ans.add(nums[0]);
            return ans;
        }

        int index = 0;
        for(int i=0; i < n; i++){
            if( dp[i][0] == LDS ){
                index = i;
                while( index < n ){
                    ans.add(nums[index]);
                    if( dp[index][1] == 0  ) break;
                    index = dp[index][1];
                }
                break;
            }
        }
        return ans;
    }
}

// Leetcode 6926 - Sort Vowels in a String

class Solution6926:
    def sortVowels(self, s: str) -> str:
        vowels = set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'])
        tmp = ""
        sorted_vowels = ""
        ans = ""
        
        for i in s:
            if i in vowels:
                sorted_vowels += i
                tmp += '2'
            else:
                tmp += i
        
        sorted_vowels = s_sorted = ''.join(sorted(sorted_vowels))
        p = 0
        for i in tmp:
            if i == '2':
                ans += sorted_vowels[p]
                p += 1
            else:
                ans += i
        
        return ans

// Leetcode 6931 - Visit Array Positions to Maximize Score

class Solution6931 {
    public long maxScore(int[] nums, int x) {
        if( nums.length == 1 ) return nums[0];
        int n = nums.length;
        int max = 0;
        long odd = 0;
        long even = 0;
        
        int evenIndex = -1;
        int oddIndex = -1;
        
        if( nums[n-1] % 2 == 0 ){
            evenIndex = n-1;
            oddIndex = -1;
        }
        else{
            evenIndex = -1;
            oddIndex = n-1;
        }
        
        for(int i=n-2; i > -1; i--){
            if( nums[i] % 2 == 0 ){
                if( evenIndex == -1 ){
                    even = Math.max(even, odd + nums[oddIndex] - x);
                }
                else if( oddIndex == -1 ){
                    even += nums[evenIndex];
                }
                else{
                    even = Math.max(even + nums[evenIndex], odd + nums[oddIndex] - x);
                }
                evenIndex = i;
            }
            else{
                if( evenIndex == -1 ){
                    odd += nums[oddIndex];
                }
                else if( oddIndex == -1 ){
                    odd = Math.max(odd, even + nums[evenIndex] - x);
                }
                else{
                    odd = Math.max(odd + nums[oddIndex], even + nums[evenIndex] - x);
                }
                oddIndex = i;
            }
            
        }
        
        if( nums[0] % 2 == 0 ) return even + nums[0];
        return odd + nums[0];

    }
}

// Leetcode 1048 - Longest String Chain

class Solution1048:
    def longestStrChain(self, words: List[str]) -> int:

        LSC = 1
        n = len(words)
        words.sort(key=lambda word: len(word))
        
        dp = [1]*n

        def same(s, t):
            a = 0
            b = 0
            diff = 0

            while a < len(s) and b < len(t):
                if s[a] == t[b]:
                    a += 1
                else:
                    diff += 1
                if diff == 2:
                    return False
                b += 1

            return True

        for i in range(n-2, -1, -1):
            for j in range(i+1, n):
                if len(words[i]) == len(words[j])-1 and same(words[i], words[j]):
                    if dp[i] < dp[j] + 1:
                        dp[i] = dp[j] + 1

            LSC = max(LSC, dp[i])

        return LSC

// Leetcode 1870 - Minimum Speed to Arrive on Time

class Solution1870 {
    public double score(int[] dist, double speed){
        double hours = 0;
        for(int i=0; i < dist.length-1; i++){
            hours += Math.ceil((double)dist[i] / speed);
        }
        return hours + (double)dist[dist.length-1] / speed;
    }
    public int binarySearch(int[] dist, int low, int high, double h){
        int k = (low+high)/2;
        double lowSpeedTime = 0;
        double highSpeedTime = 0;
        while( low <= high ){
            k = (low+high)/2;
            lowSpeedTime = score(dist, (double)(k-1));
            highSpeedTime = score(dist, (double)k);
            if( highSpeedTime == h ){
                if( lowSpeedTime > h ) return k;
                high = k-1;
            }
            else if( highSpeedTime < h ){
                if( lowSpeedTime > h ) return k;
                high = k-1;
                if( low >= high ){
                    high = low;
                    low = k-1;
                }
            }
            else low = k+1;
        }
        return -1;
    }
    public int minSpeedOnTime(int[] dist, double hour) {
        return binarySearch(dist, 0, (int)Math.pow(10,7), hour);
    }
}

// Leetcode 2226 - Maximum Candies Allocated to K Children

class Solution2226 {
    public boolean score(int[] candies, int n, long k){
        if( n == 0 ) return true;
        long piles = 0;
        for(int i=0; i < candies.length; i++){
            if( candies[i] == n ) piles++;
            else if( candies[i] > n ){
                piles += candies[i] / n;
            }
        }
        if( piles < k ) return false;
        return true;
    }
    public int binarySearch(int[] candies, int low, int high, long k){
        int mid = (low+high)/2;
        boolean lowCandies = false;
        boolean highCandies = false;
        while( low <= high ){
            mid = (low+high)/2;
            lowCandies = score(candies, mid-1, k);
            highCandies = score(candies, mid, k);
            if( highCandies == false ){
                if( lowCandies == true ) return mid-1;
                else high = mid-2;
            }
            else{
                if( score(candies, mid+1, k) == false ) return mid;
                low = mid+1;
            }
        }
        return 1;
    }
    public int maximumCandies(int[] candies, long k) {
        return binarySearch(candies, 0, (int)Math.pow(10,7), k);
    }
}

// Leetcode 1329 - Sort the Matrix Diagonally

class Solution1329:
    def verify(self, i, j):
        if i < 0 or j < 0 or i == self.m or j == self.n:
            return False
        return True
    
    def bfs(self, i, j, grid):
        org_i = i
        org_j = j
        diagonal = [grid[i][j]]
        
        while self.verify(i+1, j+1):
            i += 1
            j += 1
            diagonal.append(grid[i][j])
        
        diagonal = sorted(diagonal)
        increment = 1
        
        grid[org_i][org_j] = diagonal[0]
        
        while self.verify(org_i+1, org_j+1):
            org_i += 1
            org_j += 1
            grid[org_i][org_j] = diagonal[increment]
            increment += 1
        
    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:
        self.m = len(mat)
        self.n = len(mat[0])
        
        for j in range(self.n):
            self.bfs(0, j, mat)
        
        for i in range(1, self.m):
            self.bfs(i, 0, mat)
            
        return mat

// Leetcode 937 - Reorder Data in Log Files

class Solution(object)937:
    def is_letter(self, s):
        m = s.split(' ')
        final = ""
        for i in range(1, len(m)):
            for j in m[i]:
                if ord(j) < 97 or ord(j) > 122:
                    return (False, final)
        
        
        for i in range(1, len(m)-1):
            final += m[i] + ' '
        
        final += m[len(m)-1]
        return (True, final)
    
    def reorderLogFiles(self, logs):
        self.mp = {}
        letter_logs = []
        digit_logs = []
        response = None
        
        for i in logs:
            response = self.is_letter(i)
            if response[0]:
                letter_logs.append([i.split(' ')[0], response[1]])
            else:
                digit_logs.append(i)
        
        letter_logs.sort(key=lambda x: x[1])
        final_logs = []
        if len(letter_logs) != 0:
            new_sort = []
            response = letter_logs[0]
        
        ans = []
        
        for i in letter_logs:
            if i[1] == response:
                new_sort.append(i)
            else:
                new_sort.sort(key=lambda x: x[0])
                for j in new_sort:
                    final_logs.append(j[0]+' '+j[1])
                new_sort = [i]
            response = i[1]
        
        new_sort.sort(key=lambda x: x[0])
        for j in new_sort:
            final_logs.append(j[0]+' '+j[1])
            
        for i in final_logs:
            ans.append(i)
        
        for i in digit_logs:
            ans.append(i)
        
        return ans

// Leetcode 1395 - Count Number of Teams

class Solution1395:
    def ways(self, nums):
        n = len(nums)
        dpLess = [0]*n
        dpGreater = [0]*n
        numWays = 0
        
        for i in range(n-2, -1, -1):
            for j in range(i+1, n):
                if nums[i] > nums[j]:
                    if dpGreater[j] > 0:
                        numWays += dpGreater[j]
                    dpGreater[i] += 1
                elif nums[i] < nums[j]:
                    if dpLess[j] > 0:
                        numWays += dpLess[j]
                    dpLess[i] += 1
                    
        return numWays
                    
    def numTeams(self, rating: List[int]) -> int:      
        return self.ways(rating)

// Leetcode 790 - Domino and Tromino Tiling

class Solution {
    public int numTilings(int n) {
        int[] dp = new int[n+1];
        int MOD = 1000000007;

        if( n == 1 ) return 1;
        if( n == 2 ) return 2;
        if( n == 3 ) return 5;

        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 5;

        for(int i=4; i < n+1; i++){
            dp[i] = (int)(((long)2 * dp[i-1] + (long)dp[i-3]) % MOD);
        }

        return dp[n];
    }
}

// Leetcode 216 - Combination Sum III

class Solution216:    
    def generate(self, nums, target, path, length, visited):
        if length <= self.k and target > -1:
            if target == 0:
                path = path.split(',')[:-1]
                path = [int(i) for i in path]
                if length == self.k:
                    self.distinct.append(path)
            else:
                for i in nums:
                    if target - i > -1 and i not in visited:
                        visited.add(i)
                        self.generate(nums, target-i, path+str(i)+',', length+1, visited.copy())
    
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        self.distinct = []  
        self.sorted = set()
        self.freq = {}
        self.k = k
        arr = [1,2,3,4,5,6,7,8,9]
        
        for i in arr:
            self.freq[i] = 1
            
        self.generate(arr, n, "", 0, set())
        return self.distinct

// Leetcode 2140 - Solving Questions With Brainpower

class Solution2140:
    def f(self, i, questions, dp):
        if i >= len(questions):
            return 0

        if i in dp:
            return dp[i]

        take = questions[i][0] + self.f(i+questions[i][1]+1, questions, dp)
        not_take = not_take = self.f(i+1, questions, dp)
        dp[i] = max(take, not_take)
        
        return dp[i]

    def mostPoints(self, questions: List[List[int]]) -> int:
        dp = {}
        maximumPoints = 0
        self.f(0, questions, dp)

        for i in dp:
            maximumPoints = max(maximumPoints, dp[i])

        return maximumPoints

// Leetcode 139 - Word Break

class Solution139:
    def solve(self, i, s, t, wordDict, dp):
        if i == len(s):
            if t in wordDict:
                self.isSolved = True
                return True
            else:
                return False

        if (t, i) in dp and dp[(t, i)] == True:
            return dp[(t, i)]

        t += s[i]
        if t in wordDict:
            dp[(t, i)] = True
            self.solve(i+1, s, "", wordDict, dp)
            self.solve(i+1, s, t, wordDict, dp)
        else:
            dp[(t, i)] = False
            self.solve(i+1, s, t, wordDict, dp)

        return False

    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        dp = {}
        self.isSolved = False
        self.solve(0, s, "", wordDict, dp)
        
        return self.isSolved

// Leetcode 74 - Search a 2D Matrix

class Solution74:
    def BinarySearch(self, matrix, target):
        row = len(matrix) // 2
        low = 0
        high = len(matrix[0])-1
        mid = 0

        visited = set()
        
        while row < len(matrix) and row > -1 and low <= high:
            mid = (low+high) // 2
            if (row, mid) in visited:
                return False
            visited.add((row, mid))
            if matrix[row][mid] == target:
                return True
            
            elif matrix[row][mid] < target:
                if mid == len(matrix[0])-1:
                    row += 1
                    low = 0
                    high = len(matrix[0])-1
                else:
                    low = mid+1
            
            else:
                if mid == 0:
                    row -= 1
                    low = 0
                    high = len(matrix[0])-1
                else:
                    high = mid-1
                
        return False

    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        if len(matrix) == 1 and len(matrix[0]) == 1:
            if matrix[0][0] == target:
                return True
            return False
        return self.BinarySearch(matrix, target)

// Leetcode 1227 - Airplane Seat Assignment Probability

class Solution1227:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        if n == 1:
            return 1
        return 0.5

// Leetcode 1911 - Maximum Alternating Subsequence Sum

class Solution1911:
    def solve(self, i, nums, dp, increment):
        if i == len(nums):
            return 0

        if (i, increment) in dp:
            return dp[(i, increment)]

        take = increment * nums[i] + self.solve(i+1, nums, dp, increment * -1)
        skip = self.solve(i+1, nums, dp, increment)

        dp[(i, increment)] = max(take, skip)

        return dp[(i, increment)]


    def maxAlternatingSum(self, nums: List[int]) -> int:
        dp = {}
        self.solve(0, nums, dp, 1)
        return dp[(0,1)]

// Leetcode 2369 - Check if There is a Valid Partition For The Array

class Solution2369:
    def solve(self, i, nums, dp):
        
        if i == len(nums):
            dp[i-1] = True
            return True

        if i in dp:
            return dp[i]

        a = False
        b = False
        c = False

        if i < len(nums)-1:
            if nums[i] == nums[i+1]:
                a = self.solve(i+2, nums, dp)
            if i < len(nums)-2:
                if nums[i] == nums[i+1] and nums[i+1] == nums[i+2]:
                    b = self.solve(i+3, nums, dp)
                if nums[i] == nums[i+1]-1 and nums[i+1] == nums[i+2]-1:
                    c = self.solve(i+3, nums, dp)
        
        if a == True or b == True or c == True:
            dp[i] = True
        else:
            dp[i] = False

    def validPartition(self, nums: List[int]) -> bool:
        dp = {}
        self.solve(0, nums, dp)
        if len(nums)-1 not in dp:
            return False
        return dp[len(nums)-1]

// Leetcode 2816 - Double a Number Represented as a Linked List

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution2816:
    def iterate(self, head):
        if head != None:
            self.nodes.append(head)
            self.iterate(head.next)
            
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        self.nodes = []
        remainder = 0
        old_val = 0
        self.iterate(head)
        
        for i in range(len(self.nodes)-1, -1, -1):
            old_val = self.nodes[i].val
            self.nodes[i].val = (2*self.nodes[i].val + remainder) % 10
            
            if 2*old_val + remainder > 9:
                remainder = 1
            else:
                remainder = 0
        
        if remainder == 0:
            return head
        
        new_node = ListNode(remainder)
        new_node.next = head
        
        return new_node

// Leetcode 1014 - Best Sightseeing Pair

class Solution1014:
    def maxScoreSightseeingPair(self, values: List[int]) -> int:
        n = len(values)
        dp = [0] * n
        dp[n-1] = values[n-1] - n + 1
        maxScore = -1*float('inf')

        for i in range(n-2, 0, -1):
            dp[i] = max(dp[i+1], values[i] - i)
        
        for i in range(0, n-1):
            maxScore = max(maxScore, values[i] + i + dp[i+1])
        
        return maxScore

// Leetcode 826 - Most Profit Assigning Work

class Solution826:
    def search(self, target, arr):
        low = 0
        high = len(arr)-1
        mid = 0

        while low <= high:
            mid = (low+high) // 2
            if arr[mid] == target:
                return target
            elif arr[mid] < target:
                if mid == len(arr)-1:
                    return arr[mid]
                elif arr[mid+1] > target:
                    return arr[mid]
                low = mid+1
            else:
                high = mid-1
        
        return -1

    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:
        n = len(difficulty)
        maxProfit = 0
        mp = {}

        for i in range(n):
            if difficulty[i] not in mp:
                mp[difficulty[i]] = profit[i]
            else:
                mp[difficulty[i]] = max(mp[difficulty[i]], profit[i])
        
        sorted_map = dict(sorted(mp.items(), key=lambda item: item[0]))
        arr = []
        prefix = {}

        maximum = 0

        for i in sorted_map:
            arr.append(i)
            maximum = max(sorted_map[i], maximum)
            prefix[i] = maximum
        
        for i in worker:
            tmp = self.search(i, arr)
            if tmp != -1:
                maxProfit += prefix[tmp]
        
        return maxProfit